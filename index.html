<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="前端开发相关技术博文">
<meta name="keywords" content="前端开发 react vue 小程序 JavaScript 计算机基础">
<meta property="og:type" content="website">
<meta property="og:title" content="墨鱼">
<meta property="og:url" content="/index.html">
<meta property="og:site_name" content="墨鱼">
<meta property="og:description" content="前端开发相关技术博文">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="墨鱼">
<meta name="twitter:description" content="前端开发相关技术博文">





  
  
  <link rel="canonical" href="/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>墨鱼</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">墨鱼</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/07/23/npm-发布包的生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="swor">
      <meta itemprop="description" content="前端开发相关技术博文">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨鱼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/23/npm-发布包的生命周期/" class="post-title-link" itemprop="url">npm 发布包的生命周期</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-23 11:03:29 / 修改时间：11:22:05" itemprop="dateCreated datePublished" datetime="2019-07-23T11:03:29+08:00">2019-07-23</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端技术/" itemprop="url" rel="index"><span itemprop="name">前端技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p><code>npm publish</code> 用来发布包，发布时读取的配置是 <code>package.json</code> 文件，比如：name 为包名字，version 为版本号。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p><code>npm publish</code> 同时也用来更新包，但一定要更改 <code>package.json</code> 的 version 字段</p>
<h2 id="停更或撤销"><a href="#停更或撤销" class="headerlink" title="停更或撤销"></a>停更或撤销</h2><p>有时候我们会觉得这个包功能已经完善了，或者我放弃了，再或者我没有精力继续了等，可以使用 <code>npm deprecate &lt;pkg&gt;[@&lt;version&gt;] &lt;message&gt;</code>, 这样，npm 会给尝试安装这个包的人发警告。还有一种情况，我想让 npm 上让这个包消失，<code>npm unpublish --force</code>可以达成愿望，但必须在发布的24小时以内。并且，即使撤销成功，也再不能使用相同的名字重现发布了。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/07/23/小程序开发总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="swor">
      <meta itemprop="description" content="前端开发相关技术博文">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨鱼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/23/小程序开发总结/" class="post-title-link" itemprop="url">微信小程序开发总结</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-23 09:50:00 / 修改时间：09:50:05" itemprop="dateCreated datePublished" datetime="2019-07-23T09:50:00+08:00">2019-07-23</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端技术/" itemprop="url" rel="index"><span itemprop="name">前端技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="小程序运行环境"><a href="#小程序运行环境" class="headerlink" title="小程序运行环境"></a>小程序运行环境</h3><table>
<thead>
<tr>
<th>运行环境</th>
<th>逻辑层</th>
<th>渲染层</th>
</tr>
</thead>
<tbody><tr>
<td>iOS</td>
<td>JavaScriptCore</td>
<td>WKWebView</td>
</tr>
<tr>
<td>安卓</td>
<td>V8</td>
<td>chromium定制内核</td>
</tr>
<tr>
<td>小程序开发者工具</td>
<td>NWJS</td>
<td>Chrome WebView</td>
</tr>
</tbody></table>
<p>需要注意到，小程序运行的三个环境，其底层 <strong>执行 JavaScript</strong> 与 <strong>渲染标记（DOM）</strong> 的引擎都不一样。具体那些地方不一样，现在或者将来或许我们都不能仔细去比对，能做的或许就是在实际开发中进行测试。</p>
<h3 id="小程序宿主环境"><a href="#小程序宿主环境" class="headerlink" title="小程序宿主环境"></a>小程序宿主环境</h3><p>就像网页开发，js 脚本的宿主环境是浏览器一样，小程序的宿主环境就是微信客户端，因此小程序可以调用微信提供的能力，这类似于微信发布的网页开发工具包 <code>JS-SDK</code>，使得网页开发也能使用微信的能力。</p>
<h4 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h4><p>小程序有两种线程，一种是 WebView 线程，负责界面的渲染，一种是 JsCore 线程，负责执行 js 脚本。而一个小程序示例会存在多个界面，因此存在多个 WebView 线程。</p>
<p>这两种线程的通信由微信客户端（Native）做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。</p>


<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><p>小程序通过 <code>app.json</code> 来配置页面：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"pages"</span>:[</span><br><span class="line">    <span class="string">"pages/index/index"</span>,</span><br><span class="line">    <span class="string">"pages/logs/logs"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pages 数组中第一个默认为小程序首页。</p>
<p>小程序在微信中初始化完成后调用 <code>onLaunch</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  onLaunch: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 小程序启动之后 触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>启动小程序过程如图：</p>


<p>小程序只有一个 app 实例，由所以页面共享，因此 app 中的配置同时作用于所有页面，例如：自定义组件，样式等。</p>
<h4 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h4><p>小程序由多个页面组成，页面通过构造函数 <code>Page</code> 来注册页面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123; <span class="comment">// 参与页面渲染的数据</span></span><br><span class="line">    logs: []</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 页面渲染后 执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>一个页面由多个组件构成（类似于 html 标签，但是还是统一称作组件），组件的使用于 html 标签使用大体一致。</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>API 提供的就是微信的能力，例如获取用户信息、微信支付等等，API 大多是异步，因此处理异步问题在小程序中很常见。</p>
<h3 id="小程序代码构成"><a href="#小程序代码构成" class="headerlink" title="小程序代码构成"></a>小程序代码构成</h3><p>小程序项目文件类型有多达五种：<code>.wxml .wxss .json .js .wxs</code>。</p>
<ul>
<li><code>.wxml</code> 提供结构（html）</li>
<li><code>.wxss</code> 提供样式（css）</li>
<li><code>.json</code> 提供配置</li>
<li><code>.js</code> 提供交互逻辑</li>
<li><code>.wxs</code> js 脚本，可通过 <code>&lt;wxs&gt;</code> 组件引入，类似 <code>&lt;script&gt;</code> 标签</li>
</ul>
<p>而一个页面或者自定义组件均由以上 5 中文件组成。根据实际情况 <code>.wxss .json .wxs</code> 可不用。 </p>
<h3 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h3><p>我们知道，网页开发的交互逻辑都是通过 <code>JavaScript</code> 来操作 <code>DOM</code> 来完成；但小程序 <code>JavaScript</code> 脚本运行在 <code>JavaScriptCore</code>（IOS） 或 <code>JsCore</code>（安卓） 中，它们是不包含 <code>BOM</code> 和 <code>DOM</code> 对象的，因此小程序是不能像网页开发一样，直接操作 <code>DOM</code> 节点，这将带来诸多限制。</p>
<p>那我们要如何更新 UI 呢？这就需要理解<strong>数据驱动</strong>的概念，当前 <code>React Vue</code> 等框架均是采用这种方式来实现 <code>UI</code> 与数据的绑定，通过 <code>JavaScript</code> 来改变数据从而更新 <code>UI</code>。</p>
<p>WXML结构实际上等价于一棵Dom树，通过一个JS对象也可以来表达Dom树的结构，如图：</p>
<img src="/2019/07/23/小程序开发总结/03.png" title="WXML结构和JS对象均可以表示一棵Dom树">

<p>WXML可以先转成JS对象，然后再渲染出真正的Dom树，回到“Hello World”那个例子，我们可以看到转换的过程如图:</p>
<img src="/2019/07/23/小程序开发总结/04.png" title="WXML结构转JS对象，再转Dom树">

<p>这时，如果 <code>JavaScript</code> 将 WXML 的 JS 对象改变了，则：</p>
<img src="/2019/07/23/小程序开发总结/05.png" title="状态更新的时候，通过对比前后JS对象变化，进而改变视图层的Dom树">

<p>这就是数据驱动UI，因此，小程序的界面渲染如图：</p>
<img src="/2019/07/23/小程序开发总结/06.png" title="逻辑层传递数据到渲染层">

<h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><h4 id="页面与页面的数据传递"><a href="#页面与页面的数据传递" class="headerlink" title="页面与页面的数据传递"></a>页面与页面的数据传递</h4><ul>
<li>app 实例<br>通过 <code>getApp()</code> 全局接口，可以在小程序初始化后任何地方获取小程序实例的引用。通过操作 <code>app</code> 实例的属性做到页面与页面之间的数据共享。</li>
</ul>
<p>适合一些不需要缓存的，一次性的状态数据。</p>
<ul>
<li><p>本地缓存<br>通过 <code>wx.setStorage/wx.getStroage</code> 来操作需要缓存的数据，实现页面与页面之间的数据共享。</p>
</li>
<li><p>服务器存储<br>通过调用后端接口来实现对用户配置或状态的数据进行存储，实现页面与页面之间的数据共享。</p>
</li>
</ul>
<p>适合同一用户跨平台、跨终端的数据共享</p>
<h4 id="页面与组件"><a href="#页面与组件" class="headerlink" title="页面与组件"></a>页面与组件</h4><p>通过 <code>setData</code> 和 模版数据绑定（数据驱动概念）来实现数据传递</p>
<h4 id="组件与组件"><a href="#组件与组件" class="headerlink" title="组件与组件"></a>组件与组件</h4><ul>
<li>父组件 -&gt; 子组件：属性</li>
<li>子组件 -&gt; 父组件：事件</li>
</ul>
<h3 id="允许传递的数据类型"><a href="#允许传递的数据类型" class="headerlink" title="允许传递的数据类型"></a>允许传递的数据类型</h3><p>因为小程序使用了模版，限于 <code>JSON</code> 字符串化规则，数据中不能包含 <code>function symbol</code> 以及循环引用。</p>
<blockquote>
<p>TIP: 通过抽象节点节点的方式，可像自定义组件中传递一个组件。</p>
</blockquote>
<h3 id="与-React-的差异"><a href="#与-React-的差异" class="headerlink" title="与 React 的差异"></a>与 React 的差异</h3><p>个人决定小程序与React本质上都是已组件化的思想来组织代码，从而构建易维护、可重用的代码；都采用了 diff 算法来优化 DOM 渲染性能。但因小程序使用模版引擎，React使用JSX语法，</p>
<ul>
<li>小程序组件通信上有组多限制，例如：无法传递函数，无法直接传递组件，没有高阶组件，模版中循环，if 判断不如 js 优雅等。但模版引擎的有点在于可以通过一些特定的指令（例如: bind:tap catch:tap capture-bind:tap）可帮助开发人员快速开发。</li>
<li>React 通过JSX，DOM 结构直接表示为 JS 对象，因此 React 能够利用js语言的各种能力，几乎没有限制。但没有限制带来了强大能力的同时也带来了开发者架构负担。</li>
</ul>
<h3 id="小程序开发过程中遇到的问题"><a href="#小程序开发过程中遇到的问题" class="headerlink" title="小程序开发过程中遇到的问题"></a>小程序开发过程中遇到的问题</h3><ul>
<li>社区生态目前还太弱小，基本都要自己造轮子</li>
<li>小程序是否分包需要在一开始构建目录时就确定好，因为分包不是按配置，而是按目录，不智能</li>
<li>小程序是双线程工作，因此需要处理异步问题，但其本身虽然支持了 es6 语法，但不能成功编译成 es5,例如： async wait。需要自己解决</li>
<li>小程序使用了一部分原生组件，但当原生组件与非原生组件都绑定事件时，从原生组件冒泡到非原生组件在真机上的路径不确定，每次不一致</li>
<li>小程序事件通过DOM传递的数据存在大小写问题（如果命名包含了大写，事件对象中都是小写）</li>
<li>小程序文件上传其实是图片上传，参数 Header 配置的 content-type ，是无法成为后端接口请求的 content-type，实际上，后端接口的 header 可能是微信固定配置的 ‘image/jpg’</li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/07/15/浏览器DNS查询/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="swor">
      <meta itemprop="description" content="前端开发相关技术博文">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨鱼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/15/浏览器DNS查询/" class="post-title-link" itemprop="url">浏览器DNS查询</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-15 06:47:32 / 修改时间：07:08:33" itemprop="dateCreated datePublished" datetime="2019-07-15T06:47:32+08:00">2019-07-15</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端技术/" itemprop="url" rel="index"><span itemprop="name">前端技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a name="f1c52a7d"></a></p>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>浏览器缓存的域名是有限制的，不仅浏览器缓存大小有限制，而且缓存时间也有限制，通常情况为2-30分钟不等，域名被缓存的时间限制可以通过 TTL 属性来设置。<br>浏览器检查缓存中是否存在该域名的 IP 地址，如果存在，解析过程结束。</p>
<p><a name="f6ed12db"></a></p>
<h2 id="操作系统缓存"><a href="#操作系统缓存" class="headerlink" title="操作系统缓存"></a>操作系统缓存</h2><p>如果浏览器缓存中解析失败，则会将查询任务交给操作系统。操作系统优先查询缓存中是否存在，如存在解析结束，若不存在，则读取配置文件（在 Windows 中配置文件：C:\Windows\System32\drivers\etc\hosts ，在 Linux 中配置文件 /etc/named.conf ），如存在解析结束。<br>操作系统会缓存从配置文件中解析的结果，缓存的时间同样受这个域名的失效时间和缓存的空间大小控制。<br><br><br>操作系统中配置文件可以将任何域名解析到任何能够访问的 IP 地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码。也因为有这种本地 DNS 解析的规程，所有黑客能通过修改本地域名解析来实现<strong>域名劫持</strong>。</p>
<p><a name="86b77405"></a></p>
<h2 id="路由器缓存"><a href="#路由器缓存" class="headerlink" title="路由器缓存"></a>路由器缓存</h2><p>如果操作系统在操作系统缓存及配置文件中都解析失败，则会将域名发送至 LDNS （本地区域名服务器，该地址就是网络配置中的 DNS 服务器地址）。LDNS 会缓存域名解析结果，结果在缓存中存在则解析结束<br></p>
<p><a name="70d5c136"></a></p>
<h2 id="ISP-DNS-缓存"><a href="#ISP-DNS-缓存" class="headerlink" title="ISP DNS 缓存"></a>ISP DNS 缓存</h2><p>如果 LDNS 解析失败，LDNS 则会向根服务器发起解析请求，返回顶级国际域名服务器解析地址，然后向顶级域名服务器地址发起解析请求，返回域名服务商的解析地址，然后再向域名服务商请求解析，得到对应的 IP，告知浏览器</p>
<img src="/2019/07/15/浏览器DNS查询/lc.svg" title="浏览器DNS解析流程图解">


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/07/15/https-gist-github-com-被墙如何解决/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="swor">
      <meta itemprop="description" content="前端开发相关技术博文">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨鱼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/15/https-gist-github-com-被墙如何解决/" class="post-title-link" itemprop="url">https://gist.github.com 被墙如何解决</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-15 06:31:29 / 修改时间：06:57:19" itemprop="dateCreated datePublished" datetime="2019-07-15T06:31:29+08:00">2019-07-15</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端技术/" itemprop="url" rel="index"><span itemprop="name">前端技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>被墙往往有两种级别（<strong>封域名</strong>、<strong>封IP</strong>），很幸运 <a href="https://gist.github.com" target="_blank" rel="noopener">https://gist.github.com</a> 是封域名级别的。因此，我们才有可能通过修改本地 hosts 文件，来避免通过网关来进行域名解析，直接从本地获取 IP 地址进行访问。其技术原理可参加<a href="https://sworlife.github.io/2019/07/15/浏览器DNS查询" target="_blank" rel="noopener">浏览器DNS查询流程</a></p>
<h2 id="修改-hosts-文件"><a href="#修改-hosts-文件" class="headerlink" title="修改 hosts 文件"></a>修改 hosts 文件</h2><ol>
<li><p>获取 <a href="https://gist.github.com" target="_blank" rel="noopener">https://gist.github.com</a> 的IP地址<br>这个很不好意思说: 百度吧!
IP: 192.30.253.118</p>
</li>
<li><p>hosts 文件路径</p>
</li>
</ol>
<p>MAC: /etc/hosts</p>
<p>Windows: c/Windows/System32/drivers/etc/hosts</p>
<ol start="3">
<li>在hosts 文件末尾添加</li>
</ol>
<p><code>192.30.253.118  gist.github.com</code></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/07/14/How Browsers Work/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="swor">
      <meta itemprop="description" content="前端开发相关技术博文">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨鱼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/How Browsers Work/" class="post-title-link" itemprop="url">How Browsers Work</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-14 16:33:00 / 修改时间：16:38:43" itemprop="dateCreated datePublished" datetime="2019-07-14T16:33:00+08:00">2019-07-14</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端技术/" itemprop="url" rel="index"><span itemprop="name">前端技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="noopener">原文链接</a></p>
<p><a name="6fcf16c7"></a></p>
<h2 id="介绍（Introduction）"><a href="#介绍（Introduction）" class="headerlink" title="介绍（Introduction）"></a>介绍（Introduction）</h2><p>Web 浏览器很可能是使用最广泛的应用软件。在这本书里，我将解释其底层是如何工作的。当你在浏览器地址栏里输入 “google.com” ，直到在浏览器里展示出谷歌网页使，我们将清楚浏览器是如何实现的。<br><a name="e0a2c782"></a></p>
<h3 id="关于浏览器（The-browsers-we-will-talk-about）"><a href="#关于浏览器（The-browsers-we-will-talk-about）" class="headerlink" title="关于浏览器（The browsers we will talk about）"></a>关于浏览器（The browsers we will talk about）</h3><p>目前主要有5种使用较广泛的浏览器：Internet Explorer, Firefox, Safari, Chrome and Opera。<br>我将提供一些来自于 Firefox、Chrome 和 Safari 中的部分源码示例。<br>根据 W3C 对浏览器使用情况的统计（2009），使用 Firefox、Safari 和 Chrome 共占比接近 60%。<br>因此，目前开源浏览器在整个浏览器市场中是重要的组成部分。<br><a name="3d3e844f"></a></p>
<h3 id="浏览器主要功能（The-browser’s-main-functionality）"><a href="#浏览器主要功能（The-browser’s-main-functionality）" class="headerlink" title="浏览器主要功能（The browser’s main functionality）"></a>浏览器主要功能（The browser’s main functionality）</h3><p>浏览器主要功能就是把你选择的存在的 web 资源，通过请求从服务器展现到浏览器窗口。资源的格式通常为HTML，但也包括 PDF、图片等。资源的地址由使用者使用 URI 地址指定。更多详情参加相关网络章节。<br>浏览器解析和展现 HTML 文件的方法在 HTML 和 CSS 规范有详细说明。哪些规范由 W3C（Word Wide Web Consortium）组织维护，它是 web 的官方组织。<br>HTML 最新版本是 <a href="http://www.w3.org/TR/html401/" target="_blank" rel="noopener">4</a>。版本 5 正在制定中。CSS 最新版本是 <a href="http://www.w3.org/TR/CSS2/" target="_blank" rel="noopener">2</a>，版本 3 正在制定中。<br>多年来各浏览器只遵从一部分规范，然后开发他们自己的扩展功能，这为 web 开发者导致了严重的兼容性问题。今天大多数浏览器或多或少遵从了规范。<br>各浏览器的用户界面彼此之间有很多相似点，常见的用户界面元素有如下几种：</p>
<ul>
<li>用于填写 URI 的地址栏</li>
<li>后退和前进的按钮</li>
<li>书签选项</li>
<li>一个刷新按钮提供更新功能，一个停止按钮为正在加载中的文档提供停止更新功能</li>
<li>首页按钮提供回到首页功能</li>
</ul>
<p>奇怪的是，浏览器的用户界面没有任何正式的规范来详细说明，它仅仅是过去几年最佳实践的经验以及浏览器间相互模仿造成的。HTML5 规范没有定义一个浏览器必须具备哪些 UI 元素，但列出了一些公共的元素。地址栏、状态栏和工具栏这些位列其中。当然，还有某些浏览的独有功能，例如 Firefox 的下载管理器。更多详情参见用户界面章节。<br><a name="3f3258a4"></a></p>
<h3 id="浏览器的高级结构（The-browser’s-high-level-structure）"><a href="#浏览器的高级结构（The-browser’s-high-level-structure）" class="headerlink" title="浏览器的高级结构（The browser’s high level structure）"></a>浏览器的高级结构（The browser’s high level structure）</h3><p>浏览器有以下主要组成部分：</p>
<ol>
<li>用户界面 - 它包括了地址栏、后退/前进按钮、书签菜单等。除了用来展示网页的主窗口以为，其余没一部分都会展示出来。</li>
<li>浏览器引擎 - 用于查询和操作渲染引擎的接口。</li>
<li>渲染引擎 - 负责显示指定的内容。例如，如果要求显示的内容是 HTML，它就负责解析 HTML 和 CSS 并且在屏幕上显示出解析出的内容。</li>
<li>网络 - 用于网络呼叫，例如：HTTP 请求。它有独立于平台的接口和每个平台的底层实现。</li>
<li>UI 后端 - 用于绘制基础部件，例如：组合框和窗口。它暴露出未特定平台的通用接口。底层实现使用了操作系统的用户界面方法。</li>
<li>JavaScript 解释器 - 用于解析和执行 JavaScript 代码</li>
<li>数据存储 - 这是一个持久性层。浏览器需要再硬盘上保存所有类型的数据，例如：cookies。新 HTML 规范（HTML5）定义的 “web database”在浏览器中是完整（虽然是轻量的）的数据库。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1550392520218-f9497554-05ad-412b-8406-b33903f79a2a.png#align=left&display=inline&height=339&name=image.png&originHeight=339&originWidth=500&size=46828&status=done&width=500" alt="image.png"><br><strong>Figure 1：Browser main components.</strong></p>
<p>值得注意的是，Chrome 不同于大多数浏览器，它的渲染引擎拥有多实例 - 每个页签对应一个实例。每个页签拥有一个自己的进程。<br>我将把以上每个部分都用一个章节来详细讲解。<br><a name="fb599fcd"></a></p>
<h3 id="各组成部分之间的联系（Communication-between-the-components）"><a href="#各组成部分之间的联系（Communication-between-the-components）" class="headerlink" title="各组成部分之间的联系（Communication between the components）"></a>各组成部分之间的联系（Communication between the components）</h3><p>Firefox 和 Chrome 都开发有特定通信设施。它们将在一个特别的章节进行讲解</p>
<p><a name="2e656cba"></a></p>
<h2 id="渲染引擎（The-rendering-engine）"><a href="#渲染引擎（The-rendering-engine）" class="headerlink" title="渲染引擎（The rendering engine）"></a>渲染引擎（The rendering engine）</h2><p>渲染引擎的职责是渲染，就是在浏览器屏幕上呈现出指定的内容。<br>渲染引擎默认能呈现 HTML 和 XML 文档，以及图片。通过一个 plug-in（浏览器扩展）也能呈现其他类型。例如：PDF 使用一个 PDF 查看器扩展就能呈现。我们在一个特别的章节讨论这些插件和扩展。在这一章节我们集中在主要使用的部分——呈现使用 CSS 格式化过的 HTML 和 图片。</p>
<p><a name="6185d257"></a></p>
<h3 id="渲染引擎（Rendering-engines）"><a href="#渲染引擎（Rendering-engines）" class="headerlink" title="渲染引擎（Rendering engines）"></a>渲染引擎（Rendering engines）</h3><p>我们提到的浏览器：Firefox、Chrome 和 Safari 都建立在两个渲染引擎之上，Firefox 使用了 Gecko（一个“自制”的 Mozilla 渲染引擎）。Safari 和 Chrome 使用了 Webkit。<br>Webkit 是一个开源渲染引擎，它最初是 Linux 平台的一个引擎，后来被 Apple 修改为支持 Mac 和 Windows。在 <a href="https://webkit.org/" target="_blank" rel="noopener">https://webkit.org/</a> 可以看到更多详情。</p>
<p><a name="8eaf48bf"></a></p>
<h3 id="主要流程（The-main-flow）"><a href="#主要流程（The-main-flow）" class="headerlink" title="主要流程（The main flow）"></a>主要流程（The main flow）</h3><p>渲染引擎从网络层获取到指定文档的内容时开始工作。这通常在8K的块（每次从网络层中获取的内容）中完成。<br>之后渲染引擎处理的主要流程如下：</p>
<pre><code>![image.png](https://cdn.nlark.com/yuque/0/2019/png/189476/1550462641043-27d55467-8301-4caf-af80-9fae77b2d23d.png#align=left&amp;display=inline&amp;height=66&amp;name=image.png&amp;originHeight=66&amp;originWidth=600&amp;size=18211&amp;status=done&amp;width=600)    &lt;br /&gt;**Figure 2：Rendering engine basic flow.**&lt;br /&gt;**&lt;br /&gt;渲染引擎将以解析 HTML 文档和把标签转换为树（content tree）中的 DOM 节点开始，将解析样式数据，包含外部 CSS 文件和内联样式。样式信息与 HTML 中的视觉指令将被用来生成另一种树 - 渲染树。&lt;br /&gt;渲染树包含了一个个带有视觉属性，类似颜色和尺寸的长方形盒子。这些长方形盒子被有序地呈现在屏幕上。&lt;br /&gt;渲染树构造好之后，将通过一个布局（layout）的过程。这意味着将给每个节点一个在屏幕上出现的真实的坐标。下一阶段就是绘制（painting）- 渲染树将被遍历以及每个节点都将使用 **UI 后端层**进行绘制。&lt;br /&gt;</code></pre><p><br>重要的是要理解这是一个渐进的过程（gradual process）。为了更好的用户体验，渲染引擎会尝试尽快地在屏幕上呈现出内容。它不会等到所有HTML都被解析之后才开始构建和布局渲染树。内容的一部分在解析和呈现，同时也在持续接受网络层传来的剩余内容。<br>**
<a name="553afa95"></a></p>
<h3 id="主要流程示例（Main-flow-examples）"><a href="#主要流程示例（Main-flow-examples）" class="headerlink" title="主要流程示例（Main flow examples）"></a>主要流程示例（Main flow examples）</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1550470060151-5eb33d8f-2ad9-45cb-ab52-32e1e2bd79a2.png#align=left&display=inline&height=289&name=image.png&originHeight=289&originWidth=624&size=45038&status=done&width=624" alt="image.png"><br><strong>Figure 3: Webkit main flow</strong><br><strong><br></strong><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1550470148590-afa67184-1d25-4ba5-ad60-1861e1953cad.png#align=left&display=inline&height=290&name=image.png&originHeight=290&originWidth=624&size=112605&status=done&width=624" alt="image.png"><strong><br></strong>Figure 4: Mozilla’s Gecko rendering engine main flow<strong><br></strong><br>从图3和图4可以看出，Webkit 和 Gecko 使用了略微不同的术语，流程本质上还是一致的。<br>Gecko 把格式化后视觉元素的树称为框架树（Frame tree）。每个元素就是一个框架（Frame）。Webkit 则用术语渲染树（Render Tree）和其组成部分渲染对象（Render Objects）来表示。Webkit 使用术语布局（Layout）表示元素的位置，Gecko 则称为回流（Reflow）。连接器（Attachment）是 Webkit 用来连接DOM节点和可视化信息来创建渲染树的术语。一个较小的非语义的差异就是 Gecko 在 HTML 和 DOM tree 之间额外多了一层，称为内容槽（content sink），是一个标记 DOM 元素的工厂。下面将讨论流程汇总的每一个部分：<br>**
<a name="b1a33cb4"></a></p>
<h3 id="解析和-DOM-树结构（Parsing-and-DOM-tree-construction）"><a href="#解析和-DOM-树结构（Parsing-and-DOM-tree-construction）" class="headerlink" title="解析和 DOM 树结构（Parsing and DOM tree construction）"></a>解析和 DOM 树结构（Parsing and DOM tree construction）</h3><p><a name="76eff1b6"></a></p>
<h4 id="常规解析（Parsing-general）"><a href="#常规解析（Parsing-general）" class="headerlink" title="常规解析（Parsing - general）"></a>常规解析（Parsing - general）</h4><p>由于解析在渲染引擎中是一个非常重要的过程，因此我们将走得更深入一点。让我们开始简短的介绍下解析部分（paring）。<br>解析一个文档意味着将其翻译成一些有意义的结构 - 一些代码能够理解和使用。解析的结果通常是一个表示文档结构的结点树。我们称为解析树或者语法树。<br>例如：解析表达式“2 + 3 - 1”能返回这个树：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1550476117790-08dbf402-e174-4085-a9fb-9e048f417a95.png#align=left&display=inline&height=155&name=image.png&originHeight=155&originWidth=400&size=20276&status=done&width=400" alt="image.png"><br><strong>Figure 5: mathematical expression tree node</strong></p>
<p><a name="Grammars"></a></p>
<h5 id="Grammars"><a href="#Grammars" class="headerlink" title="Grammars"></a>Grammars</h5><p>解析基于文档遵守的语法规则（书写的语言或格式）。每种格式都必须解析出由词汇表和语法规则组成的确定性的语法。这被称为上下文无关语法（context free grammar）。人类语言不是这类语言，因此无法传统的解析技术进行解析。</p>
<p><a name="9ae131a7"></a></p>
<h5 id="（解析器-结合词法分析器）Parser-lexer-combination"><a href="#（解析器-结合词法分析器）Parser-lexer-combination" class="headerlink" title="（解析器 - 结合词法分析器）Parser - lexer combination"></a>（解析器 - 结合词法分析器）Parser - lexer combination</h5><p>解析可以被分为两个子流程：词法分析（lexical analysis）和语法分析（syntax analysis）。<br>词法分析是将输入拆分为词（token）的过程。词就是语言中的词汇表（有效构造块的集合）。在人类语言中，就是该语言在词典中出现的所有单词组成的。<br>语法分析是语言语法规则的应用。<br>解析器通常分为两部分：负责将输入拆分为有效词汇的词法分析器（lexer）或分词器（tokenizer），以及负责遵循语言规则分析出文档结构，进而构造出解析树（parse tree）的解析器。词法分析器知道如何去除无关紧要的符号，例如：空格和换行符。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1550482562198-3c0d4d3d-c644-486d-98a7-5240264baae5.png#align=left&display=inline&height=300&name=image.png&originHeight=300&originWidth=101&size=19139&status=done&width=101" alt="image.png"><br><strong>Figure 6: from source document to parse trees</strong><br>**<br>解析过程是迭代的，解析器通常向词法分析器请求新的词（token），然后尝试匹配一条语法规则，如果与一条规则匹配，与之对应的结点将被添加到解析树中，然后将继续请求另一个词（token）。<br>如果没有匹配到规则，解析器将在内部存储这个词（token），然后继续请求词（token）直到找到匹配内部存储的所有词的规则。如果没有找到规则，那么解析器将引发一个异常，这意味着该文档无效并且包含有语法错误。</p>
<p><a name="adc66e18"></a></p>
<h5 id="翻译（Translation）"><a href="#翻译（Translation）" class="headerlink" title="翻译（Translation）"></a>翻译（Translation）</h5><p>多数时候解析树不是最终产品，翻译中常使用解析 - 将输入文本翻译为另一种格式。例如汇编。把源码编译成机器码的编译程序首先将其解析成解析树，然后翻译把解析树翻译成机器码文档。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1550484895530-a863f78e-2b6d-410a-bf25-5c25a035bd23.png#align=left&display=inline&height=400&name=image.png&originHeight=400&originWidth=104&size=25384&status=done&width=104" alt="image.png"><br><strong>Figure 7: compilation flow</strong></p>
<p><a name="8469736f"></a></p>
<h5 id="解析示例（Parsing-example）"><a href="#解析示例（Parsing-example）" class="headerlink" title="解析示例（Parsing example）"></a>解析示例（Parsing example）</h5><p>图5中，我们构建了一个数学表达式的解析树，让我们尝试定义一个简单的数学语言来看看解析流程。<br>词汇表：我们的语言包括整数、加号和减号。<br>语法：</p>
<pre><code>1. 该语言语法构建块是表达式、术语和操作
1. 该语言能包括任意数量的表达式
1. 表达式（expression）定义为一个术语（term）后面跟着一个操作（operation），再跟着另一个术语（term）
1. 操作（operation）是指加号（plus token）或者减号（minus token）
1. 术语是指一个整数（integer）或者一个表达式（expression）</code></pre><p>让我们解析输入“2 + 3 - 1”。<br>第一个子串匹配到规则的是“2”，根据规则#5，它是一个术语。第二次匹配是“2 + 3”匹配到规则#2 - 一个术语后跟着一个操作再跟着另一个术语。下一次匹配将只会在输入的末尾被命中。“2 + 3 - 1”是一个表达式因为我们已经知道“2 + 3”是一个术语，因此我们拥有了一个术语后跟着一个操作再跟着另一个术语。“2 + +”将不能匹配任何规则因此是无效的输入。</p>
<p><a name="226d81c1"></a></p>
<h5 id="正式定义词汇和语法（Formal-definitions-for-vocabulary-and-syntax）"><a href="#正式定义词汇和语法（Formal-definitions-for-vocabulary-and-syntax）" class="headerlink" title="正式定义词汇和语法（Formal definitions for vocabulary and syntax）"></a>正式定义词汇和语法（Formal definitions for vocabulary and syntax）</h5><p>词汇表通常由正则表达式（<a href="https://www.regular-expressions.info/" target="_blank" rel="noopener">regular expressions</a>）表示。<br>例如我们的语言将被定义为：<br>INTEGER：0|[1-9][0-9]*<br>PLUS: +<br>MINUS: -<br>正如你所看到的，整数被定义为一个正则表达式。<br>语法通常被定义为一种 <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form" target="_blank" rel="noopener">BNF</a>（Backus–Naur form） 格式。我们的语言将被定义为：<br>expression := term operation term<br>operation := PLUS | MINUS<br>term := INTEGER | expression</p>
<p>我们说一种语言如果它的语法是无上下文语法，则能通过常规解析器被解析。无上下文语法可简单定义为语法能完全用 BNF 格式表示。正式的定义参加<a href="http://en.wikipedia.org/wiki/Context-free_grammar" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Context-free_grammar</a></p>
<p><a name="3867ff5d"></a></p>
<h5 id="解析器的类型（Types-of-parsers）"><a href="#解析器的类型（Types-of-parsers）" class="headerlink" title="解析器的类型（Types of parsers）"></a>解析器的类型（Types of parsers）</h5><p>解析器有两个基本类型 - 自上而下解析器（top down parsers）和自下而上解析器（bottom up parsers）。自上而下解析器可简单定义为解析器查看语法的高级结构，并尝试匹配其中的一个。自下而上解析器从输入开始，逐步转换为语法规则，从低级规则开始，直到能匹配高级语法为止。<br>来看看这两种解析器如何解析我们的示例：<br>自上而下解析器从最高级规则开始，它将定义“2 + 3”是一个表达式。然后定义“2 + 3 - 1”是一个表达式（定义表达式的过程会逐步匹配其他规则，但起点是最高级规则）。<br>自下而上解析器将浏览输入直到与一个规则匹配，然后用该规则替换匹配的输入。这个过程将持续到输入的结束。部分匹配出的表达式放在了解析栈上。</p>
<table>
<thead>
<tr>
<th align="center"><strong>Stack</strong></th>
<th align="center"><strong>Input</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">2 + 3 - 1</td>
</tr>
<tr>
<td align="center">term</td>
<td align="center">2 + 3 - 1</td>
</tr>
<tr>
<td align="center">term operation</td>
<td align="center">3 - 1</td>
</tr>
<tr>
<td align="center">expression</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">expression operation</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">expression</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>这种自下而上解析器被称为渐变减少解析器（shif reduce parser）,因为输入被向右平移（想象下指针从输入的开始向右移动）并逐步简化为语法规则。</p>
<p><a name="eb0a8c3e"></a></p>
<h5 id="自动生产的解析器（Generation-parsers-automatically）"><a href="#自动生产的解析器（Generation-parsers-automatically）" class="headerlink" title="自动生产的解析器（Generation parsers automatically）"></a>自动生产的解析器（Generation parsers automatically）</h5><p>有些工具能为你生成解析器。它们被称为解析生成器。你提供语言的语法给它们 - 词汇表和语法规则，然后就生成一个能工作的解析器。创建一个解析器需要深入理解解析原理并且不容易手动创建出优化的解析器，因此解析生成器非常有用。<br>Webkit 使用了两个非常好的解析生成器 - 创建词法分析程序的Flex和创建解析器的Bison（你可能会遇到它们的名称是Lex 和 Yacc）。Flex 的输入是一个包含用正则表达式定义词（token）的文件。Bison 的输入是用 BNF 格式表示的语言语法。</p>
<p><a name="3fc06d7f"></a></p>
<h4 id="HTML-解析器（HTML-Parser）"><a href="#HTML-解析器（HTML-Parser）" class="headerlink" title="HTML 解析器（HTML Parser）"></a>HTML 解析器（HTML Parser）</h4><p>HTML 解析器的工作是把 HTML 标记解析成解析树。</p>
<p><a name="b0887e49"></a></p>
<h5 id="HTML-语法定义（The-HTML-grammer-definition）"><a href="#HTML-语法定义（The-HTML-grammer-definition）" class="headerlink" title="HTML 语法定义（The HTML grammer definition）"></a>HTML 语法定义（The HTML grammer definition）</h5><p>HTML 的词汇表和语法<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#w3c" target="_blank" rel="noopener">规范</a>由 W3C 组织创建。现在的版本是HTML4，HTML5正在制定中。</p>
<p><a name="0355a922"></a></p>
<h5 id="不是上下文无关语法（Not-a-context-free-grammer）"><a href="#不是上下文无关语法（Not-a-context-free-grammer）" class="headerlink" title="不是上下文无关语法（Not a context free grammer）"></a>不是上下文无关语法（Not a context free grammer）</h5><p>正如我们在解析器介绍中看到，语法的语法能使用 BNF 等格式进行正式定义。<br>不幸的是所有传统的解析器主题都不适用于 HTML （我提到它们不是为了好玩，它们将被用于 CSS 解析和 JavaScript 解析）。HTML 不能简单地由解析器需要的上下文无关语法进行定义。<br>DTD（Document Type Definition）是一个定义 HTML 的正式格式，但不是一个上下文无关语法。<br>这在第一个站点上看起来很奇怪——HTML 非常接近 XML，有许多可用的 XML 的解析器。HTML-XHTML是一个 XML 的变体，因此它们最大区别是什么呢？<br>区别就是 HTML 更“宽容”，它默默地加上你疏忽掉特定的标记，有时省略开始或结束标记等。总的来说，它是一种“软”语法，与 XML 的硬和苛刻的语法相反。<br>很明显，这个看起来很微小的不同使得世界变得不同。一方面这是 HTML 如此流行的主要原因——它忽略你的错误，使得 web 作者的生活更容易；另一方面，它使得语法格式很难写。总结下——HTML 不容易被解析，自从它的语法不是上下文无关语法开始，既不适用于传统解析器，也不适用于 XML 解析器。</p>
<p><a name="c3a151fc"></a></p>
<h5 id="HTML-DTD"><a href="#HTML-DTD" class="headerlink" title="HTML DTD"></a>HTML DTD</h5><p>HTML定义在一个 DTD 格式里。这种格式被用于定义 <a href="https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language" target="_blank" rel="noopener">SGML</a> 家族语言。这种格式包含所有元素及其属性和层次结构的定义。正如我们前面看到的，HTML DTD 不是上下文无关语法。<br>DTD 有几种变体。严格模式严格遵守规范，但其他几种模式包含对浏览器对过去使用的标记的支持。目的是向后兼容旧的内容。现在的严格 DTD 地址：<a href="http://www.w3.org/TR/html4/strict.dtd" target="_blank" rel="noopener">http://www.w3.org/TR/html4/strict.dtd</a></p>
<p><a name="DOM"></a></p>
<h5 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h5><p>输出的树——解析树是 DOM 元素和属性的节点组成的树。DOM是 Document Object Model 的简称。它是 HTML 文档的对象表示和 HTML 元素与外部世界（如 JavaScript）的接口。<br>这个树的根节点是 <a href="https://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document" target="_blank" rel="noopener">Document</a> 对象。<br>DOM 与标记几乎是一对一的关系。例如，这些标记：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">2<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">22<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">222Hello World</span><br><span class="line">22<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">22<span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"example.png"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">2<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将被翻译为下面这样的DOM树：</p>
<pre><code>![image.png](https://cdn.nlark.com/yuque/0/2019/png/189476/1550566879833-9e2a9d27-ec5f-4a17-8669-cf8a6d42c474.png#align=left&amp;display=inline&amp;height=219&amp;name=image.png&amp;originHeight=219&amp;originWidth=400&amp;size=36649&amp;status=done&amp;width=400)&lt;br /&gt;**Figure 8: DOM tree of the example markup**</code></pre><p>如何 HTML，DOM 也由 W3C 组织具体说明，可见：<a href="https://www.w3.org/DOM/DOMTR" target="_blank" rel="noopener">https://www.w3.org/DOM/DOMTR</a>。这是一个操作文档的通用规范。特定的模块描述 HTML 特定元素。HTML 规范可在这里找到：<a href="https://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html" target="_blank" rel="noopener">https://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html</a>。<br>当我看说树中包含了 DOM 节点，我的意思是树由某个 DOM 接口的元素构建的。浏览器使用浏览器内部具有其它属性的具体实现。</p>
<p><a name="ff00c3f3"></a></p>
<h5 id="解析算法（The-parsing-algorithm）"><a href="#解析算法（The-parsing-algorithm）" class="headerlink" title="解析算法（The parsing algorithm）"></a>解析算法（The parsing algorithm）</h5><p>正如在前面几节中看到的，HTML 不能被通常的自上而下的解析器解析。<br>原因如下：</p>
<pre><code>1. 语言的宽容本性
1. 浏览器需要具有传统的错误容忍度，以支持已知的无效HTML的事实。
1. 解析过程可重入（可重入(**Reentrant**)：函数可以由多于一个线程并发使用，而不必担心数据错误。可重入函数可以在任意时刻被中断，稍后再继续运行，不会丢失数据。）。通常资源在解析过程中不会改变，但在 HTML 中，包含“document.write”的 script 标签能添加额外的词（tokens），因此解析过程实际上会修改输入。</code></pre><p>由于不能使用常规解析器技术，浏览器为解析 HTML 创建了自定义的解析器。<br>这个解析算法描述的是 HTML5 规范的细节。这个算法由<strong>标记</strong>（tokenization）和构建树两个阶段组成。<br>标记是把输入通过词法分析、解析转变成<strong>标记</strong>（tokens）。<strong>HTML 标记</strong>包含开始标记、结束标记、属性名称和属性值。<br>分词器识别出标记，将其交给构建树，然后使用下一个字符识别出下一个标记，以此类推，直到输入结束。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1550629215999-29aa6106-2b07-4b47-a084-6cacd12a174c.png#align=left&display=inline&height=400&name=image.png&originHeight=400&originWidth=308&size=35956&status=done&width=308" alt="image.png"><br>Figure 6：HTML parsing flow（taken from HTML5 spec）<br></p>
<p><a name="7c52a2b1"></a></p>
<h5 id="标记算法（The-tokenization-algorithem）"><a href="#标记算法（The-tokenization-algorithem）" class="headerlink" title="标记算法（The tokenization algorithem）"></a>标记算法（The tokenization algorithem）</h5><p>该算法输入一个 HTML 词，该算法用状态机（state machine）表示。每个状态消耗输入流的一个或多个字符，并且根据那些字符更新到下一个状态。该决策收到当前标记化状态和树构造状态的影响。这意味着根据当前的状态，消耗同一个字符将为正确的下一个状态产出不同的结果。该算法太复杂而不能完全引入，因此让我们通过一个简单的示例帮助我们理解原理。<br>基础示例 - 标记下面的 HTML:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">2<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">22Hello world</span><br><span class="line">2<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><br>初始状态是“Data state”，当遇到字符“&lt;”时，状态将被改变为“Tag open state”。继续消耗一个“a-z”的字符会创建一个“Start tag token”（开始标记），状态变为“Tag name state”。一直保持在这个状态直到字符“&gt;”被消耗。每个字符都会附件到新的标记名称上。在我们的例子中，创建的标记是一个 “html”标记。<br>当“&gt;”标签到达是，当前标记被发出并且状态变回到“Data state”。“body” 标签将被相同的步骤处理。到目前为止，“html”和“body”都已发出。现在回到“Data state”状态。消费“Hello world”中的“H”将创建并发出一个字符标记，一直持续到“”中的“&lt;”到达。这期间我们发出了“Hello world”中每一个字符的标记。现在我们回到“Tag open state”状态。继续消费下一个输入“/”将创建一个“end tag token”（结束标记）并且移动到“Tag name state”状态。再一次保持这个状态知道“&gt;”到来。然后一个新标签标记将被发出，且回到“Data state”状态。输入的“”将像之前的例子一样被处理。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1550632809798-c9530ab3-047c-45b9-8e72-28721ead5e19.png#align=left&display=inline&height=387&name=image.png&originHeight=387&originWidth=627&size=26067&status=done&width=627" alt="image.png"><br><strong>Figure 9: Tokenizing the example input</strong><br>**
<a name="3340002d"></a></p>
<h5 id="构造树算法（Tree-construction-algorithm）"><a href="#构造树算法（Tree-construction-algorithm）" class="headerlink" title="构造树算法（Tree construction algorithm）"></a>构造树算法（Tree construction algorithm）</h5><p>当解析器被创建时，文档对象也被创建。在树构造阶段，将修改文档根目录中的 DOM 树，并向其添加元素。分词器发出的每个节点都将由树构造处理。每个标记都有 DOM 元素的规范定义与之对应并为其构建。除非添加到DOM 树的元素也添加开放元素的堆栈中了。这个栈被用于纠正嵌套不匹配和未关闭的标签。该算法也描述为一个状态机。这些状态被称为插入模式（insertion modes）。<br>让我们来看看实例输入的树构造过程：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">2<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">22Hello world</span><br><span class="line">2<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>树构造阶段输入是一系列来自标记阶段的标记，第一个模式是初始模式（initial mode）。接收到这个html 标记将导致切换到“before html”模式并且在该模式下对标记重新处理。这将导致HTMLHtmlElement 元素诞生并且它将被添加到文档对象（Document Object）的根节点。<br>状态将切换到“before head”。我们接收到“body”标记，尽管我们没有“head”标记，HTMLHeadElement 元素仍会被隐含的创建并添加到树中。<br>现在我们切换到“in head”模式，然后切换到“after head”。这个 body 标记被重新加工，HTMLBodyELement 被创建并插入，且模式转换为“in body”。<br>“Hello world” 字符串的字符标记现在被接收到，第一个标记将导致一个“Text”节点被创建和插入，其他字符将被添加到这个节点上。<br>接收到body的结束标记将导致转换到“after body”模式。我们将接收到html 结束标签将切换到“after after body”模式。接收到文件结束的标记将结束解析。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1550647262722-5ddbc38a-858a-48c1-9da2-6407eff10001.png#align=left&display=inline&height=769&name=image.png&originHeight=769&originWidth=532&size=33483&status=done&width=532" alt="image.png"><br><strong>Figure 10: tree construction of example html</strong></p>
<p><a name="02ddcf2a"></a></p>
<h5 id="解析完成之后的行为（Actions-when-then-parsing-is-finished）"><a href="#解析完成之后的行为（Actions-when-then-parsing-is-finished）" class="headerlink" title="解析完成之后的行为（Actions when then parsing is finished）"></a>解析完成之后的行为（Actions when then parsing is finished）</h5><p>解析完成之后浏览器将文档标记为交互式的，并开始解析“deferred”模式中的脚本（scripts）——哪些应该在文档被解析之后被运行。文档状态之后将被设置为“complete”，且“load”事件将被激活。<br>你将在<a href="https://www.w3.org/TR/html5/syntax.html#html-parser" target="_blank" rel="noopener">HTML5 规范</a>中看到标记、书构造的完整算法。<br><a name="ae17b7a0"></a></p>
<h5 id="浏览器容错处理（Browsers-error-tolerance）"><a href="#浏览器容错处理（Browsers-error-tolerance）" class="headerlink" title="浏览器容错处理（Browsers error tolerance）"></a>浏览器容错处理（Browsers error tolerance）</h5><p>你绝不会在一个HTML页面获取到“Invalid Syntax”错误。浏览器将修复无效的内容，然后继续。拿这段HTML举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mytag</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mytag</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  	Really lousy HTML</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我必须违反上百万的规则（“mytag”不是标准标签，“p”的“div”错误嵌套），但浏览器仍然正确的展示并且没有提出抗议。因此很多解析代码都是为了修复HTML作者的错误。<br>在不同浏览器中，错误处理非常一致，但令人惊讶的是它不是HTML当前规范的一部分。就像书签和后退/前进按钮，它只是多年来浏览器开发出来的东西。他们知道在很多站点重复出现无效的HTML结构，然后和其它浏览器以一种符合要求的方式尝试去修复它们。<br>HTML5 规范确实定义其中一些需求。Webkit 在HTML 解析类开头的注释中很好的总结这一点。</p>
<blockquote>
<p>这个解析器把标记化的输入解析到文档中，创建出文档树。如果这个文档格式良好，就直接地解析它。<br>不幸的是，我们必须处理很多那些格式不够良好的文档，因此解析器必须能够容忍错误。<br>我们必须至少关心下面几种错误情形：</p>
<ol>
<li>正添加到某些外部标签的元素是被显示禁止的。这种情况，我们应该关闭被禁止元素之前的所有标签，然后将元素添加其后。</li>
<li>我们不允许直接地添加元素。可能写文档的人忘记了中间的某些标签（或其中的标签是可选的）。这可能是以下标签的情况：HTML HEAD BODY TR TD LI （我还忘记了哪些？）</li>
<li>我们想添加块级元素到一个行级元素中。关闭所有行级元素直到下一个更高级的块元素。</li>
<li>如果这没有用，关闭元素直到允许被添加的元素或者忽略这个标签。</li>
</ol>
</blockquote>
<p>让我们看一些Webkit 容错处理的例子：<br><strong><br> 替代 <br></strong><br>一些网站使用<br>替代<br>。为了被IE兼容，FIrefox Webkit 如此处理像<br>等标签。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123;</span><br><span class="line">     reportError(MalformedBRError);</span><br><span class="line">     t-&gt;beginTag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意——这个错误处理是内部的——它不会提供给用户。</p>
<ul>
<li>走失的表格（a stray table）</li>
</ul>
<p>走失的表格是指一个表格放在了另一个表格中，但确没有放在单元格中，举例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">2<span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">22<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">2<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Webkit 将修改这个结构变成两个兄弟表格：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">2<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">2<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_inStrayTableContent &amp;&amp; localName == tableTag)</span><br><span class="line">        popBlock(tableTag);</span><br></pre></td></tr></table></figure>

<p>Webkit 使用一个栈来保存当前元素内容——它将把里面的table从外部table栈中弹出。两个table之后便是兄弟关系了</p>
<ul>
<li>嵌套的表单元素（Nested form elements）</li>
</ul>
<p>这种情况是指用户将一个form 放入另一个form 中，第二个form 会被忽略。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!m_currentFormElement) &#123;</span><br><span class="line">        m_currentFormElement = <span class="keyword">new</span> HTMLFormElement(formTag,    m_document);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>太深的标签层次结构（A too deep tag hierarchy）</li>
</ul>
<p>这个注释不言自明。</p>
<blockquote>
<p><a href="http://www.liceo.edu.mx" target="_blank" rel="noopener">www.liceo.edu.mx</a> 这个站点就是一个例子，它达到了 1500个标记的嵌套级别，全部来自遗传 <b>。我们仅允许大约 20 个相同类型的嵌套标签，然后将它们全部忽略。</b></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> HTMLParser::allowNestedRedundantTag(<span class="keyword">const</span> AtomicString&amp; tagName)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (HTMLStackElem* curr = m_blockStack;</span><br><span class="line">         i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName == tagName;</span><br><span class="line">     curr = curr-&gt;next, i++) &#123; &#125;</span><br><span class="line"><span class="keyword">return</span> i != cMaxRedundantTagDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>错误放置的html或body的结束标签（Misplaced html or body end tags）<br>同样，也有相应的注释说明。<blockquote>
<p>为支持不完整的html<br>我们从不关闭body标签，除非一些愚蠢的web页面在文档实际结束之前关闭它。我们依靠 end() 的调用来关闭这些东西。</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t-&gt;tagName == htmlTag || t-&gt;tagName == bodyTag )</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>因此 web 作者要小心——除非你想在Webkit 容错处理的代码中作为实例出现——编写格式良好的HTML。</p>
<p><a name="e055ea7a"></a></p>
<h4 id="CSS-解析（CSS-parsing）"><a href="#CSS-解析（CSS-parsing）" class="headerlink" title="CSS 解析（CSS parsing）"></a>CSS 解析（CSS parsing）</h4><p>还记得介绍中的解析概念么？哦，这不像 HTML，CSS 是一个上下文无关的语法，也能使用介绍中的那类解析器来解析。事实上，CSS 规范定义了 CSS 词汇和语法（<a href="http://www.w3.org/TR/CSS2/grammar.html" target="_blank" rel="noopener">http://www.w3.org/TR/CSS2/grammar.html</a>）。</p>
<p>让我们来看一些实例：<br>词汇语法（词汇）通过正则表达式定义了每一个词：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">comment		\/\*[^*]*\*+([^/*][^*]*\*+)*\/</span><br><span class="line">num				[0-9]+|[0-9]*&quot;.&quot;[0-9]+</span><br><span class="line">nonascii	[\200-\377]</span><br><span class="line">nmstart		[_a-z]|&#123;nonascii&#125;|&#123;escape&#125;</span><br><span class="line">nmchar		[_a-z0-9-]|&#123;nonascii&#125;|&#123;escape&#125;</span><br><span class="line">name			&#123;nmchar&#125;+</span><br><span class="line">ident			&#123;nmstart&#125;&#123;nmchar&#125;*</span><br><span class="line"></span><br><span class="line">&quot;ident&quot; 是 identifier 的缩写，例如一个类名。&quot;name&quot; 是元素 id（它由&quot;#&quot;引用）</span><br></pre></td></tr></table></figure>

<p>语法使用 BNF 描述</p>
<blockquote>
<ul>
<li>*****: 0 or more</li>
<li><strong>+</strong>: 1 or more</li>
<li><strong>?</strong>: 0 or 1</li>
<li><strong>|</strong>: separates alternatives</li>
<li><strong>[ ]</strong>: grouping</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">  : selector [ &apos;,&apos; S* selector ]*</span><br><span class="line">    &apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S*</span><br><span class="line">  ;</span><br><span class="line">selector</span><br><span class="line">  : simple_selector [ combinator selector | S+ [ combinator selector ] ]</span><br><span class="line">  ;</span><br><span class="line">simple_selector</span><br><span class="line">  : element_name [ HASH | class | attrib | pseudo ]*</span><br><span class="line">  | [ HASH | class | attrib | pseudo ]+</span><br><span class="line">  ;</span><br><span class="line">class</span><br><span class="line">  : &apos;.&apos; IDENT</span><br><span class="line">  ;</span><br><span class="line">element_name</span><br><span class="line">  : IDENT | &apos;*&apos;</span><br><span class="line">  ;</span><br><span class="line">attrib</span><br><span class="line">  : &apos;[&apos; S* IDENT S* [ [ &apos;=&apos; | INCLUDES | DASHMATCH ] S*</span><br><span class="line">    [ IDENT | STRING ] S* ] &apos;]&apos;</span><br><span class="line">  ;</span><br><span class="line">pseudo</span><br><span class="line">  : &apos;:&apos; [ IDENT | FUNCTION S* [IDENT S*] &apos;)&apos; ]</span><br><span class="line">  ;</span><br><span class="line">declaration</span><br><span class="line">  : property &apos;:&apos; S* expr prio?</span><br><span class="line">  ;</span><br><span class="line">property</span><br><span class="line">  : IDENT S*</span><br><span class="line">  ;</span><br><span class="line">prio</span><br><span class="line">  : IMPORTANT_SYM S*</span><br><span class="line">  ;</span><br><span class="line">expr</span><br><span class="line">  : term [ operator? term ]*</span><br><span class="line">  ;</span><br><span class="line">term</span><br><span class="line">  : unary_operator?</span><br><span class="line">    [ NUMBER S* | PERCENTAGE S* | LENGTH S* | EMS S* | EXS S* | ANGLE S* |</span><br><span class="line">      TIME S* | FREQ S* ]</span><br><span class="line">  | STRING S* | IDENT S* | URI S* | hexcolor | function</span><br><span class="line">  ;</span><br><span class="line">function</span><br><span class="line">  : FUNCTION S* expr &apos;)&apos; S*</span><br><span class="line">  ;</span><br><span class="line">/*</span><br><span class="line"> * There is a constraint on the color that it must</span><br><span class="line"> * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])</span><br><span class="line"> * after the &quot;#&quot;; e.g., &quot;#000&quot; is OK, but &quot;#abcd&quot; is not.</span><br><span class="line"> */</span><br><span class="line">hexcolor</span><br><span class="line">  : HASH S*</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>

<p>说明：ruleset 是下面这样的结构：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.error</span>, <span class="selector-tag">a</span><span class="selector-class">.error</span> &#123;</span><br><span class="line">2<span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>div.error 和 a.error 都是 selector。在花括号中的部分包含通过这个 ruleset 应用的规则。它的结构被正式定义在这个描述中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">  : selector [ &apos;,&apos; S* selector ]*</span><br><span class="line">    &apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S*</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>

<p>这意味着一个 ruleset 是一个 selector 或者由逗号和空格分割的多个 selector（S 代表空格）组成。一个 ruleset 包含一对花括号且花括号中间是一个 declaration 或者由分号分割的多个 declaration。”declaration” 和 “selector” 将被定义在接下来的 BNF 定义中。</p>
<p><a name="5cda2ac8"></a></p>
<h5 id="Webkit-CSS-解析器（Webkit-CSS-parser）"><a href="#Webkit-CSS-解析器（Webkit-CSS-parser）" class="headerlink" title="Webkit CSS 解析器（Webkit CSS parser）"></a>Webkit CSS 解析器（Webkit CSS parser）</h5><p>Webkit 使用 <a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#parser_generators" target="_blank" rel="noopener">Flex and Bison</a> 生成器根据 CSS 语法文件自动创建解析器，正如你从解析器介绍中回想起的一样，Bison 创建一个自下而上的渐变减少解析器（shif reduce parser）。Firefox 使用手动编写的自上而下的解析器。两种情况都会把每个 CSS 文件解析成一个样式表对象（StyleSheet Object），每个对象包括了 CSS 规则。CSS 规则又包含了选择器（selector）、声明对象（declaration objects）以及其他 CSS 语法相关的对象。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1551749965864-b738d12d-7324-4c32-8348-f52989b8d99c.png#align=left&display=inline&height=393&name=image.png&originHeight=393&originWidth=500&size=50124&status=done&width=500" alt="image.png"><br><strong>Figure 7：parsing CSS</strong><br>**
<a name="5f765268"></a></p>
<h4 id="脚本解析（Parsing-scripts）"><a href="#脚本解析（Parsing-scripts）" class="headerlink" title="脚本解析（Parsing scripts）"></a>脚本解析（Parsing scripts）</h4><p>这部分将在 JavaScript 章节处理。</p>
<p><a name="ec21b793"></a></p>
<h4 id="处理脚本和样式表的顺序（The-order-of-processing-scripts-and-style-sheets）"><a href="#处理脚本和样式表的顺序（The-order-of-processing-scripts-and-style-sheets）" class="headerlink" title="处理脚本和样式表的顺序（The order of processing scripts and style sheets）"></a>处理脚本和样式表的顺序（The order of processing scripts and style sheets）</h4><p><a name="8f465117"></a></p>
<h5 id="脚本（Scripts）"><a href="#脚本（Scripts）" class="headerlink" title="脚本（Scripts）"></a>脚本（Scripts）</h5><p>web 的模型是同步的。作者期望当解析到 <script> 标记时，脚本将被解析并立即执行。将使文档的解析停止，直到脚本被执行。如果是外部脚本，该资源必须第一时间从网络抓取进来——做这些仍然是同步的。使解析停止，直到资源被请求到。这是多年来的模式，并被定义在 HTML4 和 5的规范中。</p>
<p>作者能把脚本标记为 "defer" ，因此它不会使文档解析停止并且将在解析完成之后才被执行。HTML5 新增一个选项用来标记异步脚本，因此它将通过<strong>不同的线程</strong>被解析和执行。</p>
<p><a name="4c9371ec"></a></p>
<h5 id="投机解析（Speculative-parsing）"><a href="#投机解析（Speculative-parsing）" class="headerlink" title="投机解析（Speculative parsing）"></a>投机解析（Speculative parsing）</h5><p>Webkit 和 Firefox 都做了优化，当执行脚本时，其他线程解析文档剩下的部分并且找出需要从网络中加载的其他资源并且加载它们。这些方式使得资源可以并行加载并且总体速度更好。注意——投机解析不会改变 DOM 树结构，并将其留给主解析器，它仅解析指定的外部资源，如外部脚本、样式表和图片。</p>
<p><a name="55291784"></a></p>
<h5 id="样式表（Style-sheets）"><a href="#样式表（Style-sheets）" class="headerlink" title="样式表（Style sheets）"></a>样式表（Style sheets）</h5><p>另一方面，样式表具有不同的模型，概念上来讲，样式表似乎不会改变 DOM 树，也就没有理由停止文档解析来等待样式表。然而，在文档解析阶段，脚本需要样式信息。如果样式还没有被加载和解析，脚本将得到错误的结果并且这明显地导致很多问题。这似乎是一个边缘情况但确很常见。当样式表被加载和解析时，Firefox 将阻塞所有脚本。Webkit 只在脚本试图访问某些确定样式属性时，才会阻塞脚本，这些属性可能会受到未加载的样式表的影响。</p>
<p><a name="0771ae8d"></a></p>
<h3 id="构造渲染树（Render-tree-construction）"><a href="#构造渲染树（Render-tree-construction）" class="headerlink" title="构造渲染树（Render tree construction）"></a>构造渲染树（Render tree construction）</h3><p>当DOM 树被构建好后，浏览器将构建另一个树，渲染树（render tree）。这个树是有特定顺序的会被呈现的视觉元素。这个视图代表了文档。这个树的目的是能以正确的顺序绘制内容。</p>
<p>Firefox 称渲染树中的这些元素为"frames"。Webkit 使用的术语是"renderer" 或者 "render object"。</p>
<p>一个 "renderer" 知道如何布局（layout）和 绘制（paint）它自己以及他的子级（children）。</p>
<p>Webkits RenderObject 类，也就是 "renderers" 的基类定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span>&#123;</span></span><br><span class="line">2<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">()</span></span>;</span><br><span class="line">2<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(PaintInfo)</span></span>;</span><br><span class="line">2<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> rect <span class="title">repaintRect</span><span class="params">()</span></span>;</span><br><span class="line">2Node* node;  <span class="comment">//the DOM node</span></span><br><span class="line">2RenderStyle* style;  <span class="comment">// the computed style</span></span><br><span class="line">2RenderLayer* containgLayer; <span class="comment">//the containing z-index layer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个 renderer 相当于一个长方形区域，通常与节点的 CSS 盒相符，这在 CSS2 规范中有相应的描述。它包含了几何信息，如宽、高和位置。这个盒子的类型受与节点有关的 "display" 样式属性的影响（参见<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#style_computation">style computation</a> 部分）。下面是一份 Webkit 代码，它通过"display"属性来决定渲染器（renderer）应该为一个DOM节点创建什么类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)</span><br><span class="line">&#123;</span><br><span class="line">    Document* doc = node-&gt;document();</span><br><span class="line">    RenderArena* arena = doc-&gt;renderArena();</span><br><span class="line">    ...</span><br><span class="line">    RenderObject* o = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (style-&gt;display()) &#123;</span><br><span class="line">        <span class="keyword">case</span> NONE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> INLINE:</span><br><span class="line">            o = <span class="keyword">new</span> (arena) RenderInline(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BLOCK:</span><br><span class="line">            o = <span class="keyword">new</span> (arena) RenderBlock(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> INLINE_BLOCK:</span><br><span class="line">            o = <span class="keyword">new</span> (arena) RenderBlock(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LIST_ITEM:</span><br><span class="line">            o = <span class="keyword">new</span> (arena) RenderListItem(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元素类型也需要被考虑，例如表单控件（controls）和表格（tables）有特殊的框架。在 Webkit 中，如果一个元素想创建一个特殊的渲染器（renderer），它将覆盖 "createRenderer" 方法。这些渲染器 （"renderers"）指向包含非几何信息的样式对象。</p>
<p><a name="9aac2e2a"></a></p>
<h4 id="渲染树与DOM树的关系（The-render-tree-relation-to-the-DOM-tree）"><a href="#渲染树与DOM树的关系（The-render-tree-relation-to-the-DOM-tree）" class="headerlink" title="渲染树与DOM树的关系（The render tree relation to the DOM tree）"></a>渲染树与DOM树的关系（The render tree relation to the DOM tree）</h4><p>渲染器与DOM树想对应，但不是一一对应。不可见的DOM元素不会被插入渲染树中，例如："head" 元素。display 属性值为"none"的元素也不会出现在树中（visibility 属性值为"hidden"的元素会出现在树中）。</p>
<p>DOM 元素对应几个视觉对象。通常具有复杂结构的元素不能通过单一的长方形进行描述。例如，"select" 元素有3个渲染器——一个用于呈现区域，一个用于下拉列表，一个用于按钮。当文本因宽度不够而打断成多行时，被添加的新行需要额外的渲染器。多渲染器的另一个例子是损坏的HTML。根据 CSS 规范，一个行内元素必须只包含块级元素或行内元素。对于混合的内容，将创建一个匿名的块级渲染器来包裹行内元素。</p>
<p>一些 render objects 对应一个 DOM 结点，但不在树中的同一位置。浮动和决定定位的元素脱离出正常流，放置在树中的不同位置，并映射到一个真实的框架。一个占位框架出现在该出现的地方。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1551925579994-391aa64b-a523-4268-a353-877c2cc7ab42.png#align=left&display=inline&height=396&name=image.png&originHeight=396&originWidth=731&size=55206&status=done&width=731" alt="image.png"></p>
<p><strong>Figure 11：渲染树和 匹配的DOM树。"Viewport" 是初始内容块。在 Webkit 中它就是"RenderView" 对象。</strong><br />**
<a name="205ce413"></a></p>
<h4 id="构建树的流程（The-flow-of-constructing-the-tree）"><a href="#构建树的流程（The-flow-of-constructing-the-tree）" class="headerlink" title="构建树的流程（The flow of constructing the tree）"></a>构建树的流程（The flow of constructing the tree）</h4><p>在 FIrefox 中，其外表（presentation）被注册为监听DOM更新的侦听器。外表（presentation）把框架（frame）创建委托给"FrameConstructor"，并且由它来解决样式（参看 style computation）和创建框架。</p>
<p>在 Webkit 中，把解决样式和创建渲染器（renderer）称为 "attachment"。每个 DOM 节点都有 "attach" 方法。Attachment 是同步的，节点插入 DOM 树时，调用新节点的 "attach" 方法</p>
<p>在构建过程中，把 html 和 body 标签处理成渲染树的根节点。根节点的渲染对象与CSS 规范中的包裹块（containing block）相匹配，——是包含所有其他块的最顶层块。它的尺寸就是视窗——浏览器窗口显示区域的尺寸。Firefox 称之为 ViewPortFrame，Webkit 称之为 RenderView。这就是文档指向的渲染对象。树的其余部分在DOM节点插入时构造。参看 CSS2 的这个主题页——<a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">http://www.w3.org/TR/CSS21/intro.html#processing-model</a></p>
<p><a name="f410803d"></a></p>
<h4 id="样式计算（Style-Computation）"><a href="#样式计算（Style-Computation）" class="headerlink" title="样式计算（Style Computation）"></a>样式计算（Style Computation）</h4><p>创建渲染树需要计算每个渲染对象的视觉特性。这是通过计算每个元素的样式特性来完成的。</p>
<p>样式包含各种来源的样式表，行内样式元素和HTML中的视觉特性（如“bgcolor”属性）。后者被转换为匹配CSS样式的属性。</p>
<p>这些样式表来源都是浏览器的默认样式表。样式表通过页面作者和用户样式表——这些样式表由浏览器用户提供（浏览器允许你定义自己喜欢的样式。例如在 Firefox 中，通过将样式表放在“Firefox Profile”文件夹中来实现）来提供。</p>
<p>样式计算带来以下几点困难：</p>
<ol>
<li>样式数据有非常大的结构，持有大量样式属性可能导致内存问题。</li>
<li>为每个元素找出匹配的规则时，如果不做优化，将导致性能问题。遍历全部的规则列表以找出每个元素的匹配项是一个繁重的任务。选择器可以有复杂的结构，这会导致匹配过程从一个看起来有希望的路径开始，而这个路径但被证明是无效的，而必须尝试另一个路径。例如——下面的复合选择器：</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div div div div&#123;</span><br><span class="line">2...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表示这个规则适用于 "<div>"，它是 3 个 divs 的后代。假设你想检查是否规则适用于给定的 "div" 元素。你选择树上树上的一个特定的路径去检查。你可能需要去遍历节点树，仅找到两个 divs 且规则不适用。你可能需要尝试树中的其他路径。</p>
<ol start="3">
<li>应用规则涉及十分复杂的级联规则，这些级联规则定义规则的层次结构。</li>
</ol>
<p>让我们来看看浏览器如何面对这些问题：</p>
<p><a name="0458e9d9"></a></p>
<h5 id="共享样式数据（Sharing-style-data）"><a href="#共享样式数据（Sharing-style-data）" class="headerlink" title="共享样式数据（Sharing style data）"></a>共享样式数据（Sharing style data）</h5><p>Webkit 节点引用样式对象（style Objects）（RenderStyle），在某些条件下这些对象由不同节点共享。这些节点都是同级关系，并且：</p>
<ol>
<li>这些元素必须处于相同的鼠标状态（例如：不愿写一个是 :hover 状态，而另一个不是）</li>
<li>任何元素都没有 id </li>
<li>标签名称应该匹配</li>
<li>类属性应该匹配</li>
<li>映射属性集必须相同</li>
<li>连接状态必须匹配</li>
<li>集合状态必须匹配</li>
<li>没有元素应该被属性选择器影响，这里说的受影响是指在选择器中任意位置使用属性选择器的选择器匹配。</li>
<li>元素中不能有 inline 样式属性</li>
<li>不能有同级选择器，WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。<br><a name="3042eaae"></a><h5 id="Firefox-规则树（Firefox-rule-tree）"><a href="#Firefox-规则树（Firefox-rule-tree）" class="headerlink" title="Firefox 规则树（Firefox rule tree）"></a>Firefox 规则树（Firefox rule tree）</h5>FIrefox 为了更容易计算样式，有两个额外的树——规则树(rule tree)和样式上下文树(style context tree)。Webkit 也有样式对象，但它们没有用树结构（比如：样式上下文树）进行存储，仅用DOM 节点指向其相关的样式。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1552185108339-7ecd8d4c-d059-4c13-ad40-ef354618b485.png#align=left&display=inline&height=407&name=image.png&originHeight=407&originWidth=640&size=13250&status=done&width=640" alt="image.png"><br /><strong>Figure 13: Firefox style context tree</strong><br />样式上下文包含终值。这些值是用正确的顺序应用了匹配出的所有规则进行计算，并且执行了把逻辑值转换为具体值的操作。比如：如果逻辑值是屏幕的百分比，它将被计算和转换成绝对单位。规则树的想法非常聪明。它使得节点之间能共享这些值，避免了再次计算它们。这也节省了空间。</li>
</ol>
<p>所有匹配出的规则都被存储在一个树结构中。一个路径中底部节点拥有更高权重。这个树包含了能找到的与规则匹配的所有路径。存储这些规则是惰性的。该树不会在一开始就为每一个节点计算的，而是节点样式需要被计算时，才将计算出的路径添加到树中。</p>
<p>这个方法可看成把树结构的路径作为词汇表中的词。来看看这个已经计算好的规则树。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1552187524853-7493af40-b25a-4661-956a-87ae0586d997.png#align=left&display=inline&height=261&name=image.png&originHeight=261&originWidth=400&size=25826&status=done&width=400" alt="image.png"><br />假设我们需要为内容树中另一个元素匹配出规则，并且找到的匹配规则（正确的顺序）是 B-E-I。我们在树中已经有这个路径了，因为我们已经计算过 A-B-E-I-L 的路径。我们现在将有少部分工作可做。</p>
<p>让我们看看这个树结构如何减少部分工作。</p>
<ul>
<li><strong>结构体划分（Division into structs）</strong></li>
</ul>
<p>样式上下文被拆分成结构体。这些结构体包含特定类型（如：border 或者 color）的样式信息。结构体中的所有属性都是继承的或非继承的。继承属性除非元素定义的属性，否则继承制它们的父级。非继承属性（称为重置属性）如果没有定义则使用默认值。<br />该树结构通过把所有结构体（包括计算出的终值）存储在树结构中来帮助我们。这个方法就是如果底部节点没有为结构体应用一个定义，在上部节点中的一个存储结构能被使用。</p>
<ul>
<li><strong>使用规则树计算样式上下文（Computing the style contexts using the rule tree）</strong></li>
</ul>
<p>当为确定的元素计算样式上下文时，我们首先计算出在规则树中的路径或者使用一个已经存在的。然后开始在路径中应用规则，填充结构体到我们的新的样式上下文中。我们从路径中底部节点开始——有最高优先级的那个（通常是最明确的选择器），然后遍历树结构直到结构体被填满。如果该节点的结构体没有规范，我们就能够大大的优化——去树结构上，直到我们找到明确说明的节点然后简单的指向它——这就是最好的优化——所有结构体都被共享。这节省了最终值的计算和内存。<br />如果我们找到了部分定义，则向上遍历这个树结构指定结构体填充完毕。<br />如果我们没有为结构体找到任何定义，这种情况的结构体是 "inherited" 类型——我们指向这个结构体的在内容树中的父级，这时我们也成功的共享了结构体。如果它是 reset 结构体，就会使用默认值。<br />如果最特定的节点添加了值，我们就需要一些额外的计算来把它转换为实际值。然后存储结果到这个树的节点，让它能被其子节点使用。<br />一个元素有指向同一个树节点的同级或同级元素，则它们之间可以共享整个样式上下文。</p>
<p>来看一个示例：假如有下面的 HTML</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"err"</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    this is a <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span> big error <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    this is also a</span><br><span class="line">    	<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span> very  big  error<span class="tag">&lt;/<span class="name">span</span>&gt;</span> error</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"err"</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>another error<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并且有以下规则</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>;<span class="attribute">color</span>:black&#125;</span><br><span class="line"><span class="selector-class">.err</span> &#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="selector-class">.big</span> &#123;<span class="attribute">margin-top</span>:<span class="number">3px</span>&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;<span class="attribute">margin-bottom</span>:<span class="number">4px</span>&#125;</span><br><span class="line"><span class="selector-id">#div1</span> &#123;<span class="attribute">color</span>:blue&#125;</span><br><span class="line"><span class="selector-id">#div</span> 2 &#123;<span class="attribute">color</span>:green&#125;</span><br></pre></td></tr></table></figure>

<p>为简化过程，我们只需要填充两个结构体——color 结构体 和 margin 结构体。color 结构体只包含一个成员—— color，margin 结构体包含了四个边。</p>
<p>规则树的结果看起来像这样（这些节点用“节点名称 ：所指向的规则”来标记）<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1552205532294-dde631c2-b026-47b9-bc08-fba3722a6863.png#align=left&display=inline&height=294&name=image.png&originHeight=294&originWidth=500&size=32298&status=done&width=500" alt="image.png"><br /><strong>Figure 12：The rule tree</strong><br />上下文树如下所示（节点名称：指向规则的节点）：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1552206261003-6ac07e27-5147-4078-ac45-67397eea00f9.png#align=left&display=inline&height=305&name=image.png&originHeight=305&originWidth=400&size=35349&status=done&width=400" alt="image.png"><br /><strong>Figure 13: 上下文树</strong><br />**<br />假如我们解析HTML到第二个 <div> 标签，我们需要为和这个节点创建一个样式上下文，并填充他的样式结构体。</p>
<p>我们将匹配规则，发现为这个 <div> 标签匹配出的规则是1，2 和 6。也就是说，在树结构中的路径已经存在了，因此我们的元素可以使用，我们仅需要为规则6添加另一个节点到结构树中（规则树中的F节点）。</p>
<p>我们将创建一个样式上下文并把它放到上下文树中。这个新的样式上下文将指向规则树中的F节点。</p>
<p>我们现在需要填充样式结构体。我们将从填充 margin 结构体开始。因最后的规则节点（F）没有添加 margin  结构体，我们可以向上追溯规则树，直到找到一个之前插入节点计算出的缓存结构体并使用它。我们将在节点 B 找到它，它是最上层节点定义的 margin 规则。</p>
<p>我们已经有一个color 结构体的定义了，因此不能使用缓存的结构体。因 color 有一个属性，我们不需要向上追溯规则树来填充其他属性。我们将计算终值（字符 转换为 RGB 等）并在这个节点上缓存计算出的结构体。</p>
<p>解析第二个 <span> 元素的工作甚至更简单。我们将匹配这些规则并且最终它指向规则 G，就像之前的 span。因我们有指向同一个节点的同级元素，能够共享全部样式上下文，仅需指向之前 span 的上下文即可。</p>
<p>为了包含继承自父级规则的结构体，在上下文树上做缓存（color 属性实际上是继承的，但 FIrefox 作为 reset 处理它，并且在规则树上缓存它）。</p>
<p>例如，如果我们在一个段落中位字体增加一些规则：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;font-family:Verdana;font size:10px;font-weight:bold&#125;</span><br></pre></td></tr></table></figure>

<p>然后在上下文树中，div 元素作为该段落的子级，能够与它的父级共享一样的 font 结构体。前提是没有为这个 div 定义 font 规则。</p>
<p>在 Webkit 中没有规则树，匹配声明被遍历4次。首先不重要且高优先级属性（因其他属性依赖，而被首先应用的属性——如：display）被应用，接着高优先级且重要，然后正常优先级且不重要，再然后正常优先级其重要的规则。这就是说，多次出现的属性将根据正确的层叠顺序被解析。最后出现的生效。</p>
<p>因此概况为——共享样式对象（结构体中全部或者一些）解决了问题 1 和 3。FIrefox 的规则树也有助于以正确的顺序应用属性。<br><a name="6045ba44"></a></p>
<h5 id="操纵规则以简化匹配（Manipulating-the-rules-for-an-easy-match）"><a href="#操纵规则以简化匹配（Manipulating-the-rules-for-an-easy-match）" class="headerlink" title="操纵规则以简化匹配（Manipulating the rules for an easy match）"></a>操纵规则以简化匹配（Manipulating the rules for an easy match）</h5><p>样式规则有以下几种资源：</p>
<ul>
<li><p>CSS 规则，要么在外部样式表中，要么在 style 元素汇总。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内联样式属性，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:blue"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTML 可视化属性（被映射成相关的样式规则）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">bgcolor</span>=<span class="string">"blue"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>最后两个很容易和元素匹配，因为元素拥有样式属性，并且 HTML 属性以元素为 key 就能被映射。</p>
<p>正如之前在问题 #2 中提到的，CSS 规则匹配很困难。为解决这个困难，为更容易访问，对规则进行了操作。</p>
<p>解析样式表之后，根据选择器规则被添加到几个散列表中，通过 id，类名，标签名进行映射，也有不符合这些类别的通用映射。如果选择器是一个 id，规则将被添加到 id 映射中，如果是类名则被添加到类名映射中，等等。</p>
<p>这个操作使得更容易匹配规则，将不需要查看每个的声明——我们能从映射表中为一个元素提取规则。这个优化提出95%以上的规则，以至于它们甚至不需要考虑匹配过程。</p>
<p>让我们以下面的样式规则举例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.error</span> &#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="selector-id">#messageDiv</span> &#123;<span class="attribute">height</span>:<span class="number">50px</span>&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>&#125;</span><br></pre></td></tr></table></figure>

<p>第一个规则将被插入类名映射，第二个插入 id 映射，第三个插入 标签映射。</p>
<p>HTML 片段如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>an error occurred <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">" messageDiv"</span>&gt;</span>this is a message<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们首先尝试为元素 p 查找规则。类名映射将包含一个 “error” 键，这个键下可以找到 “p.error” 规则、div 元素相关的规则在 id 映射表（键名就是 id ）和 标签映射表中。因此剩余的工作仅需找出通过键名提取出的规则中那些真正匹配的。</p>
<p>例如：如果 div 的规则如下</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>&#125;</span><br></pre></td></tr></table></figure>

<p>它仍然从标签名映射表中提取出来，因为键名是选择器的最右边，但它不匹配我们的 div 元素，它没有table 的祖先。</p>
<p>Webkit 和 FIrefox 都做这种操作。</p>
<p><a name="31a1d2db"></a></p>
<h5 id="按正确的层叠顺序应用规则（Applying-the-rules-in-the-correct-cascade-order）"><a href="#按正确的层叠顺序应用规则（Applying-the-rules-in-the-correct-cascade-order）" class="headerlink" title="按正确的层叠顺序应用规则（Applying the rules in the correct cascade order）"></a>按正确的层叠顺序应用规则（Applying the rules in the correct cascade order）</h5><p>样式对象的属性对应于每个可视属性（所有css 属性，但更通用）。如果没有通过任何匹配的规则定义——那么一些属性能从其父级元素的样式对象中继承。其他属性使用默认值。</p>
<p>当不只一个定义时，问题就开始了——接下来是解决这个问题的层叠顺序。</p>
<ul>
<li>样式表层叠顺序（Style sheet cascade order）</li>
</ul>
<p>一个样式属性的声明允许出现在多个样式表中，以及在一个样式表中的多次出现。这意味着应用规则的顺序非常重要。这就被称为“层叠”顺序。根据 CSS2 规范，层叠顺序就是（从低到高）：</p>
<ol>
<li>浏览器声明</li>
<li>用户普通声明</li>
<li>作者普通声明</li>
<li>作者重要声明</li>
<li>用户重要声明</li>
</ol>
<p>浏览器声明重要性最低，如果声明被标记为 important，用户才能覆盖作者的。<br />具有相同顺序的声明将按<a href="https://www.yuque.com/longtengsong/frontend/how_browsers_work/edit">规范</a>进行排序，然后按指定顺序排序。HTML 可视化属性被转换为匹配的 CSS 声明。它们按视为低优先级的作者规则。<br /></p>
<ul>
<li>Specifity</li>
</ul>
<p>选择器规范被定义在 <a href="https://www.w3.org/TR/CSS2/cascade.html#specificity">CSS2 规范</a>中，如下：</p>
<ul>
<li>如果声明来自 'style' 属性，而不是带有选择器的规则，则计数 1，否则计数 0 （=a）</li>
<li>计算选择器中 ID 属性的数量（=b）</li>
<li>计算选择器中其他属性和伪类的数量（=c）</li>
<li>计算选择器中元素和伪元素的数量（=d）</li>
</ul>
<p>把四个数字 a-b-c-d 连接起来（在基数很大的数制中），得到这个特性。<br />数制需要你使用类别中最大的数字来定义，例如：<br />如果 a = 14 你能使用 16 进制数。在不大可能的情况下，当 a = 17 时，你需要 17 进制数。后面这种情形可能发生，选择器像这样：html body div div p ...(在你的选择器总有17个标签。不是很可能)。<br />一些示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*             &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span></span><br><span class="line"> <span class="selector-tag">li</span>            &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span></span><br><span class="line"> <span class="selector-tag">li</span><span class="selector-pseudo">:first-line</span> &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></span><br><span class="line"> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>         &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></span><br><span class="line"> <span class="selector-tag">ul</span> <span class="selector-tag">ol</span>+<span class="selector-tag">li</span>      &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span></span><br><span class="line"> <span class="selector-tag">h1</span> + *<span class="selector-attr">[rel=up]</span>&#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span></span><br><span class="line"> <span class="selector-tag">ul</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span><span class="selector-class">.red</span>  &#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span></span><br><span class="line"> <span class="selector-tag">li</span><span class="selector-class">.red</span><span class="selector-class">.level</span>  &#123;&#125;  <span class="comment">/* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span></span><br><span class="line"> <span class="selector-id">#x34y</span>         &#123;&#125;  <span class="comment">/* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span></span><br><span class="line"> style=""          /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</span><br></pre></td></tr></table></figure>

<ul>
<li>规则排序 - Sorting the rules</li>
</ul>
<p>匹配到规则以后，则根据层叠规则进行排序。Webkit 对小列表使用冒泡排序，大列表使用合并排序。Webkit 通过重写规则的 “>” 运算符实现排序:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> spec1 = r1.selector()-&gt;specificity();</span><br><span class="line">    <span class="keyword">int</span> spec2 = r2.selector()-&gt;specificity();</span><br><span class="line">    <span class="keyword">return</span> (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="dd5e0339"></a></p>
<h4 id="渐进过程（Gradual-process）"><a href="#渐进过程（Gradual-process）" class="headerlink" title="渐进过程（Gradual process）"></a>渐进过程（Gradual process）</h4><p>Webkit 使用标记是否已加载所有顶级样式表 (包括 “导入”) 的标志。当合成渲染树时，如果样式没有完全加载——持有的位置被使用并且标记在文档中，一旦样式表加载完成，它们将重新计算。</p>
<p><a name="5baaa446"></a></p>
<h3 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h3><p>当渲染器被创建并添加到树结构中时，它还没有位置和大小。计算这些值被称为 layout 或者 reflow。</p>
<p>HTML 使用基于流的布局模型，这意味着大多数时间都可以在一个通道中计算几何图形。 “在流中” 后面的元素通常不会影响"在流中"之前的元素的几何图形，所以布局能从左至右，从上至下通过文档。有些例外——例如：HTML 表格可能需要多个通道。</p>
<p>坐标系统和根部框架有关系，使用顶部坐标和左边坐标。</p>
<p>布局是一个递归过程。它从根部的渲染器开始，与html 文档的元素相对应。布局继续递归，经过一些或者全部层叠的框架，为每一个需要的渲染器计算几何信息。</p>
<p>根渲染器的位置是0,0，尺寸是视窗——浏览器窗口的可视部分。</p>
<p>所有渲染器都有一个"layout" 或者 "reflow" 方法，每个渲染器调用其需要布局的子级的布局方法。</p>
<p><a name="8786ab91"></a></p>
<h4 id="脏位系统（Dirty-bit-system）"><a href="#脏位系统（Dirty-bit-system）" class="headerlink" title="脏位系统（Dirty bit system）"></a>脏位系统（Dirty bit system）</h4><p>为了使每一个小的变化，不做一次完整的布局，浏览器使用了“脏位”系统。改变或者新增的渲染器把自己和子级标记为“dirty”——需要布局。</p>
<p>有两个标记：“dirty” 和 “children are dirty”。Children are dirty 意味着其渲染器本身可能没有改变，但至少有一个子级需要布局。</p>
<p><a name="555f1346"></a></p>
<h4 id="全局和增量布局（Global-and-incremental-layout）"><a href="#全局和增量布局（Global-and-incremental-layout）" class="headerlink" title="全局和增量布局（Global and incremental layout）"></a>全局和增量布局（Global and incremental layout）</h4><p>布局能被整个渲染树触发——这就是“全局”布局。这将导致一些结果：</p>
<ol>
<li>全局样式变化影响所有渲染器，如字体大小变化。</li>
<li>屏幕将被重新计算</li>
</ol>
<p>布局也可能是增量的，仅修改过的渲染器被布局（这可能会导致一些损坏，这将需要额外的布局）。</p>
<p>当渲染器被修改时，增量布局被触发（异步）。例如，新的渲染器被添加到渲染树后，额外的内容来自网络，并被添加到DOM 树。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1552694567559-e81fef8f-ae06-430b-9c06-4b53de36eeb5.png#align=left&display=inline&height=341&name=image.png&originHeight=341&originWidth=326&size=7736&status=done&width=326" alt="image.png"><br /><strong>Figure 20：增量布局——仅dirty 渲染器和他们的子级被布局</strong></p>
<p><a name="8bf4bb5f"></a></p>
<h4 id="异步和同步布局（Asynchronous-and-Synchronous-layout）"><a href="#异步和同步布局（Asynchronous-and-Synchronous-layout）" class="headerlink" title="异步和同步布局（Asynchronous and Synchronous layout）"></a>异步和同步布局（Asynchronous and Synchronous layout）</h4><p>增量布局是异步的，Firefox 用放置增量布局的队列“reflow commands”和一个调度器来触发这些命令的批处理执行。Webkit 也有一个计时器来执行一个增量布局——遍历树，“dirty” 渲染器被布局。</p>
<p>脚本要求样式信息，如“offsightHeight”能触发同步增量布局。</p>
<p>全局布局通常被同步的触发。</p>
<p>有时布局会在初始布局之后作为一个回调被触发，因为一些属性，如滚动位置改变。</p>
<p><a name="Optimizations"></a></p>
<h4 id="Optimizations"><a href="#Optimizations" class="headerlink" title="Optimizations"></a>Optimizations</h4><p>当布局被“resize” 或者渲染器位置（不是大小）的改变激活，渲染的大小来自缓存而不是重新计算。<br />在一些情况下——仅子树被修改，布局是不会从跟节点开始。在本地改变且不影响周围的情况下，才可能发生——例如文本插入文本域（每个按键都将触发一个从跟节点开始的布局）。</p>
<p><a name="63964773"></a></p>
<h4 id="布局流程（The-layout-process）"><a href="#布局流程（The-layout-process）" class="headerlink" title="布局流程（The layout process）"></a>布局流程（The layout process）</h4><p>布局通常包含以下几个部分：</p>
<ol>
<li>父级渲染器确定自己的宽度。</li>
<li>父级遍历自己并：<ol>
<li>确定子级渲染器的位置（设置它的x 和 y）</li>
<li>如果需要则调用子级的布局函数（它们是脏的或者我们在全局布局中，又或者一些其他原因）——这是计算子级的高度。</li>
</ol>
</li>
<li>父级使用子级累积的高度和 margin 和 padding 的高度来设置它自己的高度——这会用在父级渲染器的父级。</li>
<li>设置它的脏位为 false。</li>
</ol>
<p>Firefox 使用“状态”对象（nsHTMLReflowState）作为参数来布局（术语：“reflow”）。除其他外，状态包括了父级的宽度。<br />FIrefox布局的输出是一个“metrics”对象（nsHTMLReflowMetrics）。它会包含渲染器计算的高度。</p>
<p><a name="1c5caf48"></a></p>
<h4 id="宽度计算（Width-calculation）"><a href="#宽度计算（Width-calculation）" class="headerlink" title="宽度计算（Width calculation）"></a>宽度计算（Width calculation）</h4><p>渲染器宽度的计算使用容器块的宽度，渲染器样式“width”属性，留白和边框。</p>
<p>例如：下面 div 的宽度计算：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 30%"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>Webkit 将按下列顺序进行计算（RenderBox 类的方法 calcWidth）：</p>
<ul>
<li>容器宽度是容器可用宽度和 0 的最大值。在这种情况下，可用宽度就是内容宽度，计算为：</li>
</ul>
<p>clientWidth() - paddingLeft() - paddingRight()<br />clientWidth 和 clientHeight 相当于一个内部对象，包括了 border 和 scrollbar。</p>
<ul>
<li>元素宽度是 “width” 样式属性。通过计算容器宽度的百分比，它会被计算成一个绝对值。</li>
<li>现在加上水平方向的 borders 和 paddings</li>
</ul>
<p>到目前为止，这是 “优先宽度” 的计算。现在最小和最大宽度将被计算。</p>
<p>如果优先宽度高于最大宽度——最大宽度被使用。如果小于最小宽度（最小不可破坏单元），那么最小宽度将被使用。</p>
<p>如果需要布局，但宽度不会更改，则缓存值。</p>
<p><a name="dcd1f22f"></a></p>
<h4 id="Line-Breaking"><a href="#Line-Breaking" class="headerlink" title="Line Breaking"></a>Line Breaking</h4><p>当正在布局中的渲染器需要被断开时，它会停止和传播到需要被打断的父级。父级将创建一个额外的渲染器并调用其布局函数。</p>
<p><a name="6e9ccdb0"></a></p>
<h3 id="绘制（Painting）"><a href="#绘制（Painting）" class="headerlink" title="绘制（Painting）"></a>绘制（Painting）</h3><p>在绘制阶段，递归渲染树并调用“paint”方法用来在屏幕上显示他们的内容。绘制使用UI基础设施组件。更多详情查看UI相关的章节。</p>
<p><a name="3339ab3e"></a></p>
<h4 id="全局和增量（Global-and-Incremental）"><a href="#全局和增量（Global-and-Incremental）" class="headerlink" title="全局和增量（Global and Incremental）"></a>全局和增量（Global and Incremental）</h4><p>就像布局，绘制也可以是全局性——绘制整个树——或者增量。在增量绘制中，一些渲染器以不影响整个树的方式更改。改变的渲染器使它在屏幕上的长方形区域无效。这导致 OS 察觉到它是一个“dirty region”并产生一个“paint”事件。OS 聪明地把几个 region 合并为一个。在 Chrome 中它更复杂，因为渲染器在一个不同于主进程的进程中。Chrome 在一定程度上模拟 OS 的行为。侦听这些事件并将消息委托给跟节点的渲染器。遍历这个树直到到达相关的渲染器。它将绘制它自己（通常是它的子级）。</p>
<p><a name="127b6bc1"></a></p>
<h4 id="The-painting-order"><a href="#The-painting-order" class="headerlink" title="The painting order"></a>The painting order</h4><p>CSS2 定义绘制流程的顺序——<a href="http://www.w3.org/TR/CSS21/zindex.html">http://www.w3.org/TR/CSS21/zindex.html</a>。真实的顺序在元素堆叠在上下文栈中。该顺序影响绘制，从栈的后面向前面进行绘制。一个block 渲染器的栈顺序是：</p>
<ol>
<li>background color</li>
<li>background image</li>
<li>border</li>
<li>children</li>
<li>outline</li>
</ol>
<p><a name="20c9ff13"></a></p>
<h4 id="Firefox-display-list"><a href="#Firefox-display-list" class="headerlink" title="Firefox display list"></a>Firefox display list</h4><p>Firefox 遍历渲染树并为绘制长方形建立展现列表。它包括渲染器相关的长方形，正确的绘画顺序（渲染器的背景，然后边框等）。</p>
<p>那种方式，渲染树仅需要为重绘遍历一次，代替了几次——绘制所有背景，然后所有图片，然后所有边框等。FIrefox 通过不增加隐藏元素优化了流程，就像元素完整在其他不透明元素的下方。</p>
<p><a name="e284a7db"></a></p>
<h4 id="Webkit-矩形存储（Webkit-rectangle-storage）"><a href="#Webkit-矩形存储（Webkit-rectangle-storage）" class="headerlink" title="Webkit 矩形存储（Webkit rectangle storage）"></a>Webkit 矩形存储（Webkit rectangle storage）</h4><p>重绘之前，Webkit 保存了老的长方形作为位图。它之后仅需绘制新的或老的交叉的部分。</p>
<p><a name="02423c12"></a></p>
<h3 id="动态改变（Dynamic-changes）"><a href="#动态改变（Dynamic-changes）" class="headerlink" title="动态改变（Dynamic changes）"></a>动态改变（Dynamic changes）</h3><p>浏览器尝试在响应更改时执行尽可能少的操作。因此元素颜色的变化仅会引起元素的重绘。元素位置的改变会引起元素、它的子节点和可能的兄弟节点的布局和重绘。新增一个DOM节点会导致节点的布局和重绘。重要的改变，例如“html”元素的字体大小改变，将导致缓存无效，布局和重绘整个树。</p>
<p><a name="9605f8cd"></a></p>
<h3 id="渲染引擎的线程（The-rendering-engine-s-threads）"><a href="#渲染引擎的线程（The-rendering-engine-s-threads）" class="headerlink" title="渲染引擎的线程（The rendering engine's threads）"></a>渲染引擎的线程（The rendering engine's threads）</h3><p>渲染引擎是单线程。几乎所有事情都发现在单线程中，网络操作除外。在 FIrefox 和 Safari 中，这是浏览器的主线程。在 Chrome 中，它是标签进程的主线程。</p>
<p>网络操作可以由多个并行线程执行，并行连接的数量有限（通常2-6个连接，FIrefox 3个，例如：使用6个）。</p>
<p><a name="bf580377"></a></p>
<h4 id="事件循环（Event-loop）"><a href="#事件循环（Event-loop）" class="headerlink" title="事件循环（Event loop）"></a>事件循环（Event loop）</h4><p>浏览器主线程是一个事件循环。它是一个无限循环，使进程保持活力。它等待事件（例如布局和绘制事件）并处理它们。这是 FIrefox 事件循环的主要代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!mExiting)</span><br><span class="line">    NS_ProcessNextEvent(thread);</span><br></pre></td></tr></table></figure>

<p><a name="5540ebe2"></a></p>
<h3 id="CSS2视觉模型（CSS2-visual-model）"><a href="#CSS2视觉模型（CSS2-visual-model）" class="headerlink" title="CSS2视觉模型（CSS2 visual model）"></a>CSS2视觉模型（CSS2 visual model）</h3><p><a name="7c4f91be"></a></p>
<h4 id="The-canvas"><a href="#The-canvas" class="headerlink" title="The canvas"></a>The canvas</h4><p>根据 CSS2 <a href="https://www.w3.org/TR/CSS21/intro.html#processing-model">规范</a>，术语 canvas 描述“呈现格式结构的空间。”——浏览器绘制内容的地方。</p>
<p>canvas 的空间每个维度都是无限的，但浏览器根据视窗的尺寸选择初始宽度。</p>
<p>根据 <a href="http://www.w3.org/TR/CSS2/zindex.html">http://www.w3.org/TR/CSS2/zindex.html</a>，如果 canvas 包含在另一个里，canvas 是透明的 ，如果不是，则给定一个浏览器定义的颜色。</p>
<p><a name="2c6f9512"></a></p>
<h4 id="CSS-盒模型（CSS-Box-model）"><a href="#CSS-盒模型（CSS-Box-model）" class="headerlink" title="CSS 盒模型（CSS Box model）"></a>CSS 盒模型（CSS Box model）</h4><p><a href="http://www.w3.org/TR/CSS2/box.html">CSS box model</a> 定义了为文档树中的元素生成的矩形盒子并根据视觉格式模型布局出来。<br />每个盒子都有一个内容区域（例如：文本、图片等等）和周期可选的 padding、border、和 margin 区域。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1553051247330-c63ab743-74da-461d-a869-1fbb0e372c14.png#align=left&display=inline&height=348&name=image.png&originHeight=348&originWidth=509&size=62400&status=done&width=509" alt="image.png"><br /><strong>Figure 14：css2 box model</strong><br />**<br />每个节点生成 0 - n 个这样的盒子。<br />所有元素都有一个 “display” 属性用来定义它们将要创建的盒子类型。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block  - generates a block box.</span><br><span class="line">inline - generates one or more inline boxes.</span><br><span class="line">none - no box is generated.</span><br></pre></td></tr></table></figure>

<p>默认值是 inline，但浏览器样式表设置了其他默认值。例如：“div” 元素的默认的 display 是 block。<br />你可以在 <a href="http://www.w3.org/TR/CSS2/sample.html">http://www.w3.org/TR/CSS2/sample.html</a> 找到一个默认样式表。</p>
<p><a name="a0dc7b43"></a></p>
<h4 id="定位方案（Positioning-scheme）"><a href="#定位方案（Positioning-scheme）" class="headerlink" title="定位方案（Positioning scheme）"></a>定位方案（Positioning scheme）</h4><p>有三种方案：</p>
<ol>
<li>正常——对象根据其在文档中的位置进行定位——这意味着它在渲染树中的位置就像它在 dom 树中的位置一样，并根据其盒子的类型和尺寸进行布局。</li>
<li>浮动——对象先像正常流一样布局，然后尽可能移动到最左侧或最右侧。</li>
<li>绝对——对象在渲染树中的位置与其在dom树中的位置不一样</li>
</ol>
<p>该定位方案通过“position”属性和“float”属性设置。</p>
<ul>
<li>static 和 relative 导致正常流</li>
<li>absolute 和 fixed 导致 绝对定位</li>
</ul>
<p>在 static 定位中，不定义位置并使用默认定位。其他方案中，作者定义position ——top、bottom、left、right。</p>
<p>盒子的布局方式是由以下信息决定的：</p>
<ul>
<li>盒子类型</li>
<li>盒子尺寸</li>
<li>定位方案</li>
<li>外部信息——例如图片大小和屏幕大小</li>
</ul>
<p><a name="a8cfbf39"></a></p>
<h4 id="Box-types"><a href="#Box-types" class="headerlink" title="Box types"></a>Box types</h4><p>块级盒子：形状是一个块——在浏览器窗口上有它们自己的矩形。<br /><br><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1553063265266-5e18f13b-6f7b-4c7c-a54a-b43f6f1f6020.png#align=left&display=inline&height=127&name=image.png&originHeight=127&originWidth=150&size=4624&status=done&width=150" alt="image.png"><br /><strong>Figure 15：块级盒子</strong><br /><strong><br />内联盒子：没有自己的块，但被包裹在块中。<br /><br><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1553063359794-16bbb0db-b14f-4569-8ef0-837f9ea877a6.png#align=left&display=inline&height=233&name=image.png&originHeight=233&originWidth=300&size=14095&status=done&width=300" alt="image.png"><br /></strong>Figure 15：内联盒子**</p>
<p>块在垂直方向一个接一个被格式化。行级在水平方向格式化。<br /><br><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1553063513712-06fe3242-3610-4e6a-83d7-9d4161fa5d8c.png#align=left&display=inline&height=324&name=image.png&originHeight=324&originWidth=350&size=22725&status=done&width=350" alt="image.png"><br /><strong>Figure 16：块和行格式化</strong></p>
<p>行级盒子放置在行内或行级盒子里。这些行至少和最高的盒子一样高，但是可以更高，当盒子以“baseline”进行对齐时，意思是元素的底部部分与其他盒子的底部对齐。这种情况容器宽度不够，这些行内盒子将放置成多行。这通常在段落中发生。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1553064101870-a36481ff-4af9-49c3-8b5f-55cad404eb89.png#align=left&display=inline&height=277&name=image.png&originHeight=277&originWidth=400&size=34538&status=done&width=400" alt="image.png"><br /><strong>Figure 17：行</strong></p>
<p><a name="ef4f8692"></a></p>
<h4 id="定位（Positioning）"><a href="#定位（Positioning）" class="headerlink" title="定位（Positioning）"></a>定位（Positioning）</h4><p><a name="ea733563"></a></p>
<h5 id="相对（Relative）"><a href="#相对（Relative）" class="headerlink" title="相对（Relative）"></a>相对（Relative）</h5><p>相对定位——像通常一样定位，然后按要求的位置移动</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1553064694798-54ab7b71-7599-427a-8a39-b009d21de76a.png#align=left&display=inline&height=261&name=image.png&originHeight=261&originWidth=500&size=28221&status=done&width=500" alt="image.png"><br /><strong>Figure 18:相对定位</strong><br />**
<a name="Floats"></a></p>
<h5 id="Floats"><a href="#Floats" class="headerlink" title="Floats"></a>Floats</h5><p>浮动的盒子被挪动的行的左边或右边。这个有趣的特性就是其他盒子围绕它流动，HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"float:right"</span> <span class="attr">src</span>=<span class="string">"images/image.gif"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span>Lorem ipsum dolor sit amet, consectetuer...</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>看起像这样<br /><br><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1553065599543-e25ed63d-0631-4e05-8387-bc085c65cd43.png#align=left&display=inline&height=203&name=image.png&originHeight=203&originWidth=444&size=10403&status=done&width=444" alt="image.png"><br /><strong>Figure 19:Float</strong><br />**
<a name="f7dc1be2"></a></p>
<h5 id="绝对和固定（Absolute-and-fixed）"><a href="#绝对和固定（Absolute-and-fixed）" class="headerlink" title="绝对和固定（Absolute and fixed）"></a>绝对和固定（Absolute and fixed）</h5><p>这种布局被定义为完全不理会正常流。元素不参加正常流。尺寸是相对于容器的。固定定位——容器就是视窗。<br /><br><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1553066037531-82965a95-f48b-40a4-8774-5e88224cec4a.png#align=left&display=inline&height=343&name=image.png&originHeight=343&originWidth=500&size=29304&status=done&width=500" alt="image.png"><br /><strong>Figure 20:Fixed positioning</strong></p>
<blockquote>
<p>注意事项——固定盒子不会移动，即使文档被滚动。</p>
</blockquote>
<p><a name="69b75e00"></a></p>
<h4 id="分层表示（Layered-representation）"><a href="#分层表示（Layered-representation）" class="headerlink" title="分层表示（Layered representation）"></a>分层表示（Layered representation）</h4><p>这是通过CSS属性 z-index 来定义的。它相对于盒子的第三个维度，它的位置属于“z 轴”。</p>
<p>盒子被分割成栈（叫作上下文栈）。这些盒子被分割为堆栈 (称为堆栈上下文)。在每个堆栈中，后面的元素将首先绘制，顶部的前向元素将更接近用户。如果重叠，将隐藏前元素。</p>
<p>堆栈根据 z-index 属性进行排序。带有 z-index 属性的盒子来自一个本地栈。视窗是独立于栈之外的。<br />例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">  div &#123; </span><br><span class="line">    position: absolute; </span><br><span class="line">    left: 2in; </span><br><span class="line">    top: 2in; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">2<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"z-index: 3;background-color:red; width: 1in; height: 1in; "</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">2<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"z-index: 1;background-color:green;width: 2in; height: 2in;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>展示结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/189476/1553068582490-7c9d9293-77c8-4d79-9f31-badb8897abc4.png#align=left&display=inline&height=227&name=image.png&originHeight=227&originWidth=254&size=1908&status=done&width=254" alt="image.png"><br /><strong>Figure 20:固定定位</strong><br />**<br />虽然绿色的 div 是在红色的 div 之前，并且在正常流之前已经被绘制，但 z-index 属性更高，因此，它在根节点盒子持有的堆栈中更靠前。</p>
<p><a name="Resources"></a></p>
<h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><ol>
<li>Browser architecture<ol>
<li>Grosskurth, Alan. A Reference Architecture for Web Browsers. <a href="http://grosskurth.ca/papers/browser-refarch.pdf">http://grosskurth.ca/papers/browser-refarch.pdf</a>.</li>
</ol>
</li>
<li>Parsing<ol>
<li>Aho, Sethi, Ullman, Compilers: Principles, Techniques, and Tools (aka the "Dragon book"), Addison-Wesley, 1986</li>
<li>Rick Jelliffe. The Bold and the Beautiful: two new drafts for HTML 5. <a href="http://broadcast.oreilly.com/2009/05/the-bold-and-the-beautiful-two.html">http://broadcast.oreilly.com/2009/05/the-bold-and-the-beautiful-two.html</a>.</li>
</ol>
</li>
<li>Firefox<ol>
<li>L. David Baron, Faster HTML and CSS: Layout Engine Internals for Web Developers. <a href="http://dbaron.org/talks/2008-11-12-faster-html-and-css/slide-6.xhtml">http://dbaron.org/talks/2008-11-12-faster-html-and-css/slide-6.xhtml</a>.</li>
<li>L. David Baron, Faster HTML and CSS: Layout Engine Internals for Web Developers(Google tech talk video). <a href="http://www.youtube.com/watch?v=a2_6bGNZ7bA">http://www.youtube.com/watch?v=a2_6bGNZ7bA</a>.</li>
<li>L. David Baron, Mozilla's Layout Engine. <a href="http://www.mozilla.org/newlayout/doc/layout-2006-07-12/slide-6.xhtml">http://www.mozilla.org/newlayout/doc/layout-2006-07-12/slide-6.xhtml</a>.</li>
<li>L. David Baron, Mozilla Style System Documentation. <a href="http://www.mozilla.org/newlayout/doc/style-system.html">http://www.mozilla.org/newlayout/doc/style-system.html</a>.</li>
<li>Chris Waterson, Notes on HTML Reflow. <a href="http://www.mozilla.org/newlayout/doc/reflow.html.Chris">http://www.mozilla.org/newlayout/doc/reflow.html.Chris</a> Waterson, Gecko Overview. <a href="http://www.mozilla.org/newlayout/doc/gecko-overview.htm">http://www.mozilla.org/newlayout/doc/gecko-overview.htm</a>.</li>
<li>Alexander Larsson, The life of an HTML HTTP request. <a href="https://developer.mozilla.org/en/The_life_of_an_HTML_HTTP_request">https://developer.mozilla.org/en/The_life_of_an_HTML_HTTP_request</a>.</li>
</ol>
</li>
<li>Webkit<ol>
<li>David Hyatt, Implementing CSS(part 1). <a href="http://weblogs.mozillazine.org/hyatt/archives/cat_safari.html">http://weblogs.mozillazine.org/hyatt/archives/cat_safari.html</a>.</li>
<li>David Hyatt, An Overview of WebCore. <a href="http://weblogs.mozillazine.org/hyatt/WebCore/chapter2.html">http://weblogs.mozillazine.org/hyatt/WebCore/chapter2.html</a>.</li>
<li>David Hyatt, WebCore Rendering. <a href="http://webkit.org/blog/114/">http://webkit.org/blog/114/</a>.</li>
<li>David Hyatt, The FOUC Problem. <a href="http://webkit.org/blog/66/the-fouc-problem/">http://webkit.org/blog/66/the-fouc-problem/</a>.</li>
</ol>
</li>
<li>W3C Specifications<ol>
<li>HTML 4.01 Specification. <a href="http://www.w3.org/TR/html4/">http://www.w3.org/TR/html4/</a>.</li>
<li>HTML5 Specification. <a href="http://dev.w3.org/html5/spec/Overview.html">http://dev.w3.org/html5/spec/Overview.html</a>.</li>
<li>Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. <a href="http://www.w3.org/TR/CSS2/">http://www.w3.org/TR/CSS2/</a>.</li>
</ol>
</li>
<li>Browsers build instructions<ol>
<li>Firefox. <a href="https://developer.mozilla.org/en/Build_Documentation">https://developer.mozilla.org/en/Build_Documentation</a></li>
<li>Webkit. <a href="http://webkit.org/building/build.html">http://webkit.org/building/build.html</a></li>
</ol>
</li>
</ol>
</script></p>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/07/14/Promises-A-规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="swor">
      <meta itemprop="description" content="前端开发相关技术博文">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨鱼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/Promises-A-规范/" class="post-title-link" itemprop="url">Promises/A+ 规范</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-14 16:29:52 / 修改时间：16:37:26" itemprop="dateCreated datePublished" datetime="2019-07-14T16:29:52+08:00">2019-07-14</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端技术/" itemprop="url" rel="index"><span itemprop="name">前端技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p><a href="http://wiki.commonjs.org/wiki/Promises" target="_blank" rel="noopener">原文链接 - Promises</a></p>
<h3 id="Promises-1"><a href="#Promises-1" class="headerlink" title="Promises"></a>Promises</h3><p>Promises 提供一个定义良好的接口，用于与一个对象交互，该对象表示异步执行的操作的结果，在任何给定的时间点可以完成，也可以不完成。通过利用一个接口标准，不同部件可以返回异步操作的 promises，并且其消费者能以可预测的方式利用这个 promises 。Promises 也能提供基本实体，以便使用它们进行语法上更方便的语言级扩展，从而帮助实现异步性。</p>
<h3 id="现有的技术"><a href="#现有的技术" class="headerlink" title="现有的技术"></a>现有的技术</h3><p><strong>略</strong></p>
<h3 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h3><ul>
<li><a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener">Promises/A</a> by Kris Zyp — “Thenables”</li>
<li><a href="http://wiki.commonjs.org/wiki/Promises/B" target="_blank" rel="noopener">Promises/B</a> by Kris Kowal — Opaque Q API</li>
<li><a href="http://wiki.commonjs.org/wiki/Promises/KISS" target="_blank" rel="noopener">Promises/KISS</a> by AJ ONeal</li>
<li>Promises/C has been redacted</li>
<li><a href="http://wiki.commonjs.org/wiki/Promises/D" target="_blank" rel="noopener">Promises/D</a> by Kris Kowal — “Promise-sendables”, for interoperable instances of Promises/B.</li>
</ul>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul>
<li><ol>
<li>如果一个函数接受一个 promise 作为它的输入，那么函数本身必须返回一个 promise 作为它的输出。提供一个简单机制用以保证，处理程序员错误，非决定论和恶意：</li>
</ol>
</li>
<li><p>1.1. 保护函数内部的一致性，使其避免来自提供输入 promise 的提供者的攻击</p>
</li>
<li><p>1.2. 保护函数内部的一致性，使其避免来自消费输出 promise 的消费者的攻击</p>
</li>
<li><p>1.3. 保护每个接受输出 promise 的接收方不受其他接收方的影响</p>
</li>
<li><p>1.4. 阻止把输入的 promise 泄露给输出消费者。表达式的返回值绝不能是输入 promise，也不能让消费者获取对输入promise 直接接的访问权</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function API(input) &#123;</span><br><span class="line">    return when(input, function (input) &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如，一个密码校验 API 必须能持有对密码散列表的引用，但绝不能让使用者直接访问这些散列表中的任何一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function PasswordChecker(accounts) &#123;</span><br><span class="line">    return function (user, password) &#123;</span><br><span class="line">        var passwordHash = Q.get(accounts, user);</span><br><span class="line">        return when(passwordHash, function (passwordHash) &#123;</span><br><span class="line">            if (hash(password) === passwordHash)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// returns a password checking capability</span><br><span class="line">// but does not return access to the passwordHash</span><br><span class="line">return PasswordChecker(accounts);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>1.4. 当输入解析后，如果发现还有额外未解析的输入，允许函数转发一个新的 promise</p>
</li>
<li><p>1.5. 允许函数要么转发其输入的失败，要么通过转发已解析的值从失败中恢复，要么通过转发一个新的承诺来恢复，最终解析或稍后失败。</p>
</li>
<li><ol start="2">
<li>避免交叉危险</li>
</ol>
</li>
<li><p>2.1. 防止 proimise 消费者在以下反例中直接使用 promise 提供者的回调:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var internalCounter = 0;</span><br><span class="line"></span><br><span class="line">// /!\ HAZARD: untrusted promise given direct access to a</span><br><span class="line">// function that has the capability to alter internal</span><br><span class="line">// state, either during the same turn or in any future turn</span><br><span class="line">promise(&quot;when&quot;, function () &#123;</span><br><span class="line">    internalCounter++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// /!\ HAZARD: untrusted promise given direct access to a</span><br><span class="line">// function that has the capability to alter internal</span><br><span class="line">// state, either during the same turn or in any future turn</span><br><span class="line">promise.when(function () &#123;</span><br><span class="line">    internalCounter++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// /!\ HAZARD: untrusted promise given direct access to a</span><br><span class="line">// function that has the capability to alter internal</span><br><span class="line">// state, either during the same turn or in any future turn</span><br><span class="line">promise.then(function () &#123;</span><br><span class="line">    internalCounter++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ASSERT.equal(internalCounter, 0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.2. 防止 promise 提供者在调用消费者的内部回调时调用与注册时相同的轮数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// /!\ HAZARD: untrusted promise given direct access to a</span><br><span class="line">// function that has the capability to alter internal</span><br><span class="line">// state, either during the same turn or in any future turn</span><br><span class="line">var internalCounter = 0;</span><br><span class="line">when(promise, function () &#123;</span><br><span class="line">    internalCounter++;</span><br><span class="line">&#125;);</span><br><span class="line">ASSERT.equal(internalCounter, 0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.3. 防止 promise 提供者多次调用消费者内部回调或者错误回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var internalCounter = 0;</span><br><span class="line">when(promise, function (value) &#123;</span><br><span class="line">    internalCounter++;</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">    internalCounter++;</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    ASSERT.ok(internalCounter == 0 || internalCounter == 1);</span><br><span class="line">&#125;, forever);</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="3">
<li>将“解决”与“观察解决”的关注点分开。</li>
</ol>
</li>
<li><p>3.1. 允许API安全地生成“延迟”，保留“解析器”部分，并将“promise”组件分发给任意数量的相互怀疑的消费者。</p>
</li>
<li><p>3.2. “竞争性竞争”:允许API安全地生成“延迟”，保留“承诺”部分，并将“解析器”组件分发给任何数量的相互怀疑的消费者。</p>
</li>
<li><ol start="4">
<li>提供一种机制，允许承诺使用者在可疑承诺尝试多次解析的任何情况下抛出异常。</li>
</ol>
</li>
<li><ol start="5">
<li>提供对任意消息传递到承诺的支持，包括支持拦截没有显式提供处理程序的任意消息。</li>
</ol>
</li>
</ul>
<h3 id="相关讨论"><a href="#相关讨论" class="headerlink" title="相关讨论"></a>相关讨论</h3><p><strong>略</strong></p>
<h2 id="Promises-A"><a href="#Promises-A" class="headerlink" title="Promises/A"></a>Promises/A</h2><p><a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener">原文链接 - Promises/A</a></p>
<h3 id="提议"><a href="#提议" class="headerlink" title="提议"></a>提议</h3><p><code>promise</code> 相当于单个操作完成后返回的最终的结果。<code>promise</code> 的状态可能是 <code>unfulfilled , fulfilled , failed</code>三种中的一个。</p>
<p>它或许只能从 <code>unfulfilled</code> 状态迁移到 <code>fulfilled</code> 状态，或者从<code>unfulfilled</code>状态迁移到 <code>failed</code>状态。</p>
<p>一旦 <code>promise</code> 处于<code>fulfilled</code> 或者 <code>failed</code> 状态，这个 <code>promise</code> 的值必须不能被修改，仅作为一个值，存在于 JavaScript 中，就像“原语”（primitives）和“对象标识”（object identities）一样，不能改变（尽管对象本身可能总是可变的，但对象标识不会。）。</p>
<p>这中不可改变的特性于 <code>promise</code> 来说很重要，它既能避免来自监听者的副作用，监听者在其行为中能创造意想不到的变化；也允许 <code>promises</code> 被传递给其他函数而不影响其调用者，这与“原语”被传递给函数而不用担心其调用者的变量被该函数的执行改变的方式一样。</p>
<p>这个 API 没有定义如何创建 <code>promises</code>，而仅定义了 <code>promise</code> 必须提供必要的接口，<code>promise</code> 的消费者通过它来交流信息。实现者可以自由定义如何创建 <code>promises</code>。一些 <code>promises</code> 可以提供自己的函数来实现 <code>promise</code>，而其他 <code>promises</code> 则可能通过一种对 <code>promise</code> 消费者不可见的机制来实现。请参阅[Promise Manager] API以获得有用的方便函数的建议。</p>
<p>承诺本身也可能包括其他额外的便利方法。例如，可以在承诺(如addCallback和addBoth)上实现Dojo的延迟函数。</p>
<p>promise被定义为一个对象，它有属性 <code>then</code>，且其值为函数 :</p>
<p><strong>then(fulfilledHandler, errorHandler, progressHandler)</strong><br>为完成的 <code>promise</code> 添加将要被调用的 <code>fulfilledHandler</code>、<code>errorHandler</code> 和 <code>progressHandler</code> 回调函数。当 <code>promise</code> 被实现时，调用 <code>fullledhandler</code>。当 <code>promise</code> 失败时调用 <code>errorHandler</code>。<code>progressHandler</code> 用于调用进度事件。所有参数都是可选的，非函数值将被忽略。<code>progressHandler</code> 不仅是一个可选参数，而且进度事件完全是可选的。<code>Promise</code> 实现者不需要调用 <code>progressHandler</code> (progressHandler可以被忽略)，这个参数的存在使得实现者可以调用它，如果他们有进度事件要报告的话。</p>
<p>这个函数应该返回一个新的 <code>promise</code>，这个 <code>promise</code> 将在给定的 <code>fulfilledHandler</code> 或 <code>errorHandler</code>回调函数条件下完成实现。并允许将 <code>promise</code> 通过链式操作链接在一起。回调处理程序返回的值是返回的 <code>promise</code> 的实现值。如果回调引发错误，返回的 <code>promise</code> 将被移动到failed状态。</p>
<p>使用CommonJS兼容承诺的一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asyncComputeTheAnswerToEverything().</span><br><span class="line">   then(addTwo).</span><br><span class="line">   then(printResult, onError);</span><br><span class="line"> 44</span><br></pre></td></tr></table></figure>

<p>可交互的 <code>promise</code> 是一种扩展的 <code>promise</code>，支持以下附加功能：</p>
<p><strong>get(propertyName)</strong><br>从此承诺的目标请求给定的属性。返回一个承诺，以提供来自此承诺的目标的声明属性的值。</p>
<p><strong>call(functionName, arg1, arg2, …)</strong><br>请求在此承诺的目标上调用给定的方法/函数。返回一个承诺，以提供所请求函数调用的返回值。</p>
<h3 id="Open-Issues"><a href="#Open-Issues" class="headerlink" title="Open Issues"></a>Open Issues</h3><p>对回调处理程序的调用应该放在事件队列中还是立即执行?-目前还不确定，我也不确定什么是最好的。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>略…</p>
<h2 id="Promises-A-1"><a href="#Promises-A-1" class="headerlink" title="Promises/A+"></a>Promises/A+</h2><p><a href="https://promisesaplus.com" target="_blank" rel="noopener">原文链接</a></p>
<p>一个开放的标准，为可交互的 Javascript promises 而发声。                    —— 实现者，为实现者</p>
<p><code>promise</code> 表示异步操作的最终结果。与 <code>promise</code> 交互的主要方式是通过其 <code>then</code> 方法，该方法注册回调以接收承诺的最终值或无法实现承诺的原因。</p>
<p>该规范详细描述了then方法的行为，提供了一个可互操作的基础，所有承诺/A+符合约定的承诺实现都可以依赖于该基础来提供。因此，应该认为该规范非常稳定。虽然 <code>promise /A+</code> 组织可能偶尔会修改这个规范，进行少量向后兼容的更改来处理新发现的角用例，但是只有在仔细考虑、讨论和测试之后，我们才会集成大型的或向后不兼容的更改。</p>
<p>从历史上看，<code>promise /A+</code> 阐明了早期<a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener">promise /A proposal</a>的行为条款，将其扩展到涵盖事实行为，并省略了未指定或有问题的部分。</p>
<p>最后，核心 <code>promist/A+</code> 规范不处理如何创建、实现或拒绝承诺，而是选择专注于提供一个互操作的then方法。将来在配套规范中的工作可能会涉及这些主题。</p>
<h3 id="1-术语"><a href="#1-术语" class="headerlink" title="1. 术语"></a>1. 术语</h3><p>1.1. “promise” 是一个带有 <code>then</code> 方法的对象或者函数，它的行为遵从改规范<br>1.2. “thenable” 是一个定义 <code>then</code> 方法的对象或者函数<br>1.3. “value” 是一个任意 Javascript 法定的值（包括 <code>undefined</code>, <code>thenable</code>, <code>promise</code>）
1.4. “exception” 是一个使用 <code>throw</code> 声明抛出的值<br>1.5. “reason” 是一个表示 <code>promise</code> 被拒绝的原因的值</p>
<h3 id="2-需求"><a href="#2-需求" class="headerlink" title="2. 需求"></a>2. 需求</h3><h4 id="2-1-Promise-状态"><a href="#2-1-Promise-状态" class="headerlink" title="2.1. Promise 状态"></a>2.1. Promise 状态</h4><p>一个 <code>promise</code> 必须处于以下三种状态中的一种：<code>pending</code>, <code>fulfilled</code>, <code>rejected</code></p>
<p>2.1.1. <code>pending</code> 状态时，<code>promise</code>：</p>
<ul>
<li>2.1.1.1. 可能转变为 <code>fulfilled</code> 或者 <code>rejected</code> 状态</li>
</ul>
<p>2.1.2. <code>fulfilled</code> 状态时，<code>promise</code>：</p>
<ul>
<li>2.1.2.1. 绝不能再转变为其他任何状态</li>
<li>2.1.2.2. 必须有 <code>value</code>，且不可改变</li>
</ul>
<p>2.1.3. <code>rejected</code> 状态时，<code>promise</code>:</p>
<ul>
<li>2.1.3.1. 绝不能再转变为其他任何状态</li>
<li>2.1.3.2. 必须有 <code>reason</code>, 且不可改变</li>
</ul>
<p>这儿，“不可改变” 意思是不变的身份（即：<code>===</code>）, 但并不意味着深层次的不变性</p>
<h4 id="2-2-then-方法"><a href="#2-2-then-方法" class="headerlink" title="2.2. then 方法"></a>2.2. <code>then</code> 方法</h4><p><code>promise</code> 必须提供 <code>then</code> 方法来访问当前或最终的 <code>value</code> 或者 <code>reason</code> </p>
<p><code>promise</code> 的 <code>then</code> 方法接受两个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>

<p>2.2.1. <code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数：</p>
<ul>
<li>2.2.1.1. 如果 <code>onFulfilled</code> 不是函数，则必须忽略</li>
<li>2.2.1.2. 如果 <code>onRejected</code> 不是函数，则必须忽略</li>
</ul>
<p>2.2.2. 如果 <code>onFulfilled</code> 是函数：</p>
<ul>
<li>2.2.2.1 它必须在 <code>promise</code> 实现之后被调用，把 <code>promise</code> 的 <code>value</code> 作为其第一个参数</li>
<li>2.2.2.2. 它绝不能在 <code>promise</code> 实现之前被调用</li>
<li>2.2.2.3. 它绝不能调用多次</li>
</ul>
<p>2.2.3. 如果 <code>onRejected</code> 是函数：</p>
<ul>
<li>2.2.3.1. 它必须在 <code>promise</code> 拒绝之后被调用，把 <code>promise</code> 的 <code>reason</code> 作为其第一个参数</li>
<li>2.2.3.2. 它绝不能在 <code>promise</code> 拒绝之前被调用</li>
<li>2.2.3.3.  它绝不能调用多次</li>
</ul>
<p>2.2.4. 在上下文堆栈中只包含<strong>平台代码</strong>之前，绝不能调用 <code>onFulfilled</code> 或 <code>onRejected</code> [3.1]</p>
<p>2.2.5. <code>onFulfilled</code> 或 <code>onRejected</code> 只能作为函数被调用。[3.2]</p>
<p>2.2.6. <code>then</code> 可能被同一个 <code>promise</code> 多次调用。</p>
<ul>
<li>2.2.6.1. 如果/当 <code>promise</code> 是完成的，所有各自的 <code>onFulfilled</code> 回调必须按照初始调用 <code>then</code> 的顺序执行。</li>
<li>2.2.6.2. 如果/当 <code>promise</code> 是拒绝的，所有各自的 <code>onRejected</code> 回调必须按照初始调用 <code>then</code> 的顺序执行。</li>
</ul>
<p>2.2.7. <code>then</code> 必须返回一个 <code>promise</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>

<ul>
<li>2.2.7.1. 如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回的 <code>value</code> 为 <code>x</code>，则运行 <code>Promise</code> 决议子程序 <code>[[Resolve]](promise2, x)</code>。</li>
<li>2.2.7.2. 如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code>, <code>promise2</code> 必须把 <code>e</code> 作为 <code>reason</code> 进行拒绝。</li>
<li>2.2.7.3. 如果 <code>onFulfilled</code> 不是函数，并且 <code>promise1</code> 已经完成，<code>promise2</code> 必须以与 <code>promise1</code> 相同的 <code>value</code> 来完成</li>
<li>2.2.7.4. 如果 <code>onRejected</code> 不是函数，并且 <code>promise1</code> 已经拒绝，<code>promise2</code> 必须以与 <code>promise1</code> 相同的 <code>reason</code> 来拒绝</li>
</ul>
<h4 id="2-3-Promise-Resolution-子程序"><a href="#2-3-Promise-Resolution-子程序" class="headerlink" title="2.3. Promise Resolution 子程序"></a>2.3. Promise Resolution 子程序</h4><p>Promise Resolution 子程序是以 <code>promise</code> 和 <code>value</code> 为输入的抽象操作，表示为：<code>[[Resolve]](promise, x)</code>。如果 <code>x</code> 是 <code>thenable</code>，它企图使 <code>promise</code> 采用 <code>x</code> 的状态，在这一假定下，<code>x</code> 行为至少有点像 <code>promise</code>。否则，它将用 <code>x</code> 作为 <code>value</code> 来完成 <code>promise</code>。</p>
<p><code>thenables</code> 的这种处理运行 <code>promise</code> 实现互操作，只要他们公开 <code>Promise/A+</code> 兼容的 <code>then</code> 方法。它也允许 <code>Promise/A+</code> 实现使用合理的 <code>then</code> 方法“吸收”不一致的实现。</p>
<p>运行 <code>[[Resolve]](promise, x)</code>，执行以下步骤：</p>
<p>2.3.1. 如果 <code>promise</code> 和 <code>x</code> 指向同一个对象，则以 <code>TypeError</code> 为由拒绝 <code>promise</code></p>
<p>2.3.2. 如果 <code>x</code> 是一个 <code>promise</code>, 则采用它的状态 [3.4]：</p>
<ul>
<li>2.3.2.1. 如果 <code>x</code> 状态为 <code>pending</code>，<code>promise</code> 必须保持 <code>pending</code>  状态，直到 <code>x</code> 被完成或者拒绝。</li>
<li>2.3.2.2. 如果/当 <code>x</code> 被完成，则用相同的 <code>value</code> 完成 <code>promise</code></li>
<li>2.3.2.3. 如果/当 <code>x</code> 被拒绝，则用相同的 <code>reason</code> 拒绝 <code>promise</code></li>
</ul>
<p>2.3.3. 否则，如果 <code>x</code> 是一个对象或者函数，</p>
<ul>
<li>2.3.3.1. 让 <code>then</code> 为 <code>x.then</code>. [3.5]</li>
<li>2.3.3.2. 如果检索属性 <code>x.then</code> 导致抛出异常 <code>e</code>，则以 <code>e</code> 为由拒绝 <code>promise</code></li>
<li>2.3.3.3. 如果 <code>then</code> 是函数，用 x 做上下文 <code>this</code>,  <code>resolvePromise</code> 做第一个参数，<code>rejectPromise</code> 做第二个参数来执行它，这儿：<ul>
<li>2.3.3.3.1. 如果/当 <code>resolvePromise</code> 被调用时，它的 <code>value</code> 是 <code>y</code>，运行 <code>[[Resolve]](promise, y)</code>.</li>
<li>2.3.3.3.2. 如果/当 <code>rejectPromise</code> 被调用时，它的 <code>reason</code> 时 <code>r</code>，则以 <code>r</code> 理由拒绝 <code>promise</code>.</li>
<li>2.3.3.3.3. 如果同时调用resolvePromise和rejectPromise，或者对同一个参数进行多个调用，那么第一个调用优先，任何进一步的调用都被忽略。</li>
<li>2.3.3.3.4. 如果调用 <code>then</code> 抛出异常 <code>e</code>,<ul>
<li>2.3.3.3.4.1. 如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 都被调用，则忽略。</li>
<li>2.3.3.3.4.2. 否则以 <code>e</code> 为理由拒绝 <code>promise</code>。</li>
</ul>
</li>
</ul>
</li>
<li>2.3.3.4. 如果<code>then</code> 不是函数，用 <code>x</code> 完成 <code>promise</code>.</li>
</ul>
<p>2.3.4. 如果 <code>x</code> 不是对象或者函数，则用 <code>x</code> 完成 <code>promise</code></p>
<p>如果 <code>promise</code>以参与循环的 thenable 链作为 <code>value</code> 来完成，使得 <code>[[Resolve]](promise, thenable)</code> 的递归性质最终导致再次调用 <code>[[Resolve]](promise, thenable)</code>，那么按照上面的算法将导致无限递归。我们鼓励实现(但不是必需的)检测这种递归并拒绝承诺，理由是信息类型错误。[3.6]</p>
<h4 id="3-备注"><a href="#3-备注" class="headerlink" title="3. 备注"></a>3. 备注</h4><p>3.1. 这儿所说的“平台代码”是指引擎、环境、和 <code>promise</code> 的代码实现。在实践中，这个需求确保 <code>onFulfilled</code> 和 <code>onRejected</code> 在调用 <code>then</code> 的事件循环之后异步执行，和一个新的栈。这可以通过“宏任务”机制(如setTimeout或setimmediation)实现，也可以通过“微任务”机制(如MutationObserver或process.nextTick)实现。由于 <code>promise</code> 实现被认为是平台代码，所以它本身可能包含一个任务调度队列或“蹦床”，在其中调用处理程序。</p>
<p>3.2. 也就是说，在严格模式下，这在它们内部是没有定义的;在非严格模式下，它将是全局对象。</p>
<p>3.3. 实现可能允许 <code>promise2 === promise1</code>，前提是实现满足所有需求。每个实现都应该记录它是否可以生成 <code>promise2 === promise1</code>，以及在什么条件下生成。</p>
<p>3.4. 通常，只有当 <code>x</code> 来自当前实现时才知道它是一个真正的 <code>promise</code>。此子句允许使用特定于实现的方法来采用已知一致性 promises 的状态。</p>
<p>3.5. 这个过程首先存储对AA的引用，然后测试该引用，然后调用该引用，从而避免了对AA属性的多次访问。这些预防措施对于确保访问器属性的一致性非常重要，因为访问器属性的值在检索之间可能会发生变化。</p>
<p>3.6. 实现不应该对 thenable 链的深度设置任意的限制，并且假设超过这个任意的限制，递归将是无限的。只有真正的死循环才会导致 <code>TypeError</code>; 如果遇到一个由不同 thenable 组成的无限链，则永远递归是正确的行为。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/07/14/布局方案汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="swor">
      <meta itemprop="description" content="前端开发相关技术博文">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨鱼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/布局方案汇总/" class="post-title-link" itemprop="url">布局方案汇总</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-14 16:28:30" itemprop="dateCreated datePublished" datetime="2019-07-14T16:28:30+08:00">2019-07-14</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-18 05:31:27" itemprop="dateModified" datetime="2019-07-18T05:31:27+08:00">2019-07-18</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端技术/" itemprop="url" rel="index"><span itemprop="name">前端技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="水平布局"><a href="#水平布局" class="headerlink" title="水平布局"></a>水平布局</h2><ul>
<li><p>inline-block + text-align</p>
  <img width="483" alt="layout_1" src="https://user-images.githubusercontent.com/33422051/59660716-d772c880-91db-11e9-9704-ee5748d30988.png">
</li>
<li><p>table + margin</p>
  <img width="484" alt="layout_2" src="https://user-images.githubusercontent.com/33422051/59660738-ebb6c580-91db-11e9-8e42-30a1d89b73ec.png">
</li>
<li><p>absoulte + transform</p>
<img width="480" alt="layout_3" src="https://user-images.githubusercontent.com/33422051/59660759-f7a28780-91db-11e9-9ba7-f4e0e848d4f3.png">
</li>
<li><p>flex + justify-content/margin</p>
  <img width="477" alt="layout_4" src="https://user-images.githubusercontent.com/33422051/59660811-05f0a380-91dc-11e9-8ba7-c00902728945.png">
  <img width="479" alt="layout_5" src="https://user-images.githubusercontent.com/33422051/59660820-0852fd80-91dc-11e9-8b9a-398d32d71f7f.png">

</li>
</ul>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><ul>
<li><p>table-cell + vertical-align</p>
  <img width="323" alt="layout_6" src="https://user-images.githubusercontent.com/33422051/59660844-156fec80-91dc-11e9-93d7-aed719fa3df5.png">
</li>
<li><p>absoulte + transform</p>
  <img width="322" alt="layout_7" src="https://user-images.githubusercontent.com/33422051/59660888-2fa9ca80-91dc-11e9-832c-5c86a5437672.png">
</li>
<li><p>flex + align-items</p>
  <img width="325" alt="layout_8" src="https://user-images.githubusercontent.com/33422051/59660928-4cde9900-91dc-11e9-9774-84123a4dea02.png">

</li>
</ul>
<h2 id="居中（水平垂直居中）"><a href="#居中（水平垂直居中）" class="headerlink" title="居中（水平垂直居中）"></a>居中（水平垂直居中）</h2><ul>
<li><p>inline-block + text-align + table-cell + vertical-align</p>
  <img width="491" alt="layout_9" src="https://user-images.githubusercontent.com/33422051/59660958-641d8680-91dc-11e9-9c20-a977374abd9b.png">
</li>
<li><p>absoulte + transform</p>
  <img width="489" alt="layout_10" src="https://user-images.githubusercontent.com/33422051/59660959-64b61d00-91dc-11e9-8c8c-6bac04eae0f2.png">
</li>
<li><p>flex + justify-content + align-items</p>
  <img width="487" alt="layout_11" src="https://user-images.githubusercontent.com/33422051/59660962-654eb380-91dc-11e9-92e6-2f245242796d.png">

</li>
</ul>
<h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><h3 id="定宽-自适应"><a href="#定宽-自适应" class="headerlink" title="定宽 + 自适应"></a>定宽 + 自适应</h3><ul>
<li><p>float + margin</p>
  <img width="475" alt="layout_12" src="https://user-images.githubusercontent.com/33422051/59660963-65e74a00-91dc-11e9-9e72-eb85a0ade2ed.png">
</li>
<li><p>float + overflow</p>
  <img width="427" alt="layout_13" src="https://user-images.githubusercontent.com/33422051/59660965-65e74a00-91dc-11e9-98d3-31e5af67373f.png">
</li>
<li><p>table</p>
  <img width="427" alt="layout_14" src="https://user-images.githubusercontent.com/33422051/59660966-667fe080-91dc-11e9-821b-63eba116a35c.png">
</li>
<li><p>flex</p>
  <img width="426" alt="layout_15" src="https://user-images.githubusercontent.com/33422051/59660968-67b10d80-91dc-11e9-8235-61d51663a042.png">

</li>
</ul>
<h3 id="多列定宽-自适应"><a href="#多列定宽-自适应" class="headerlink" title="多列定宽 + 自适应"></a>多列定宽 + 自适应</h3><ul>
<li>与定宽 + 自适应的布局方式一样，例如使用 float + overflow：  <img width="427" alt="layout_16" src="https://user-images.githubusercontent.com/33422051/59660969-67b10d80-91dc-11e9-8dd5-41ab0d52a73f.png">

</li>
</ul>
<h3 id="不定宽-自适应"><a href="#不定宽-自适应" class="headerlink" title="不定宽 + 自适应"></a>不定宽 + 自适应</h3><p>不定宽的部分，宽带由内容来决定</p>
<ul>
<li><p>float + overflow</p>
  <img width="425" alt="layout_17" src="https://user-images.githubusercontent.com/33422051/59660970-6849a400-91dc-11e9-96ca-4ceb11a3e5dd.png">
</li>
<li><p>table</p>
  <img width="425" alt="layout_18" src="https://user-images.githubusercontent.com/33422051/59660972-6849a400-91dc-11e9-960f-8ca8d9f27c89.png">
</li>
<li><p>flex</p>
  <img width="427" alt="layout_19" src="https://user-images.githubusercontent.com/33422051/59660974-68e23a80-91dc-11e9-82ff-18f4ee1dc6c2.png">

</li>
</ul>
<h3 id="多列不定宽-自适应"><a href="#多列不定宽-自适应" class="headerlink" title="多列不定宽 + 自适应"></a>多列不定宽 + 自适应</h3><p>与不定宽 + 自适应一样</p>
<h3 id="等宽"><a href="#等宽" class="headerlink" title="等宽"></a>等宽</h3><ul>
<li><p>float</p>
  <img width="437" alt="layout_20" src="https://user-images.githubusercontent.com/33422051/59660975-68e23a80-91dc-11e9-9cf5-3a266159ba2b.png">
</li>
<li><p>table</p>
  <img width="437" alt="layout_21" src="https://user-images.githubusercontent.com/33422051/59660979-697ad100-91dc-11e9-839d-68c4c3831da0.png">
</li>
<li><p>flex</p>
  <img width="430" alt="layout_22" src="https://user-images.githubusercontent.com/33422051/59660985-6aabfe00-91dc-11e9-9342-c6e81ebeef10.png">

</li>
</ul>
<h3 id="等高"><a href="#等高" class="headerlink" title="等高"></a>等高</h3><ul>
<li><p>table</p>
  <img width="430" alt="layout_23" src="https://user-images.githubusercontent.com/33422051/59660991-6da6ee80-91dc-11e9-8fd2-32fc3138e3be.png">
</li>
<li><p>flex</p>
  <img width="424" alt="layout_24" src="https://user-images.githubusercontent.com/33422051/59660993-6da6ee80-91dc-11e9-9af5-5af93fc9d3ac.png">
</li>
<li><p>float</p>
 <img width="425" alt="layout_25" src="https://user-images.githubusercontent.com/33422051/59660994-6e3f8500-91dc-11e9-82be-f2b0c9029331.png"></li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/07/14/git-commit-规范工具的应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="swor">
      <meta itemprop="description" content="前端开发相关技术博文">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨鱼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/git-commit-规范工具的应用/" class="post-title-link" itemprop="url">git commit 规范工具的应用</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-14 16:27:01 / 修改时间：16:27:33" itemprop="dateCreated datePublished" datetime="2019-07-14T16:27:01+08:00">2019-07-14</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端技术/" itemprop="url" rel="index"><span itemprop="name">前端技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="git-commit-规范"><a href="#git-commit-规范" class="headerlink" title="git commit 规范"></a>git commit 规范</h2><h3 id="Angular-提交规范"><a href="#Angular-提交规范" class="headerlink" title="Angular 提交规范"></a>Angular 提交规范</h3><p>编码需要规范，git 提交代码也应该有其规范，业内普遍参考 Angular 提交的规范。下面来介绍 Angular 的提交规范：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; #header</span><br><span class="line">// 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>

<p>从格式上看，整个 message 分为了 三个部分：</p>
<ul>
<li><p>header: 整个 header 部分尽量不要这行。它包含三个字段：type（必需）、scope（可选）和 subject(必需)。</p>
<ul>
<li><p>type</p>
<ul>
<li>feat: 新功能 feature</li>
<li>fix: 修补 bug</li>
<li>docs: 文档 documentation</li>
<li>style: 格式——不影响代码运行的变动</li>
<li>refactor: 重构——既不是新增功能，也不是修改 bug 的代码变动</li>
<li>test: 增加测试</li>
<li>chore: 构建多次或辅助工具的变动</li>
<li>revert: 用于撤销以前的 commit，有着特定的格式：<ul>
<li>header: <code>rever: &lt;被撤销的header&gt;</code></li>
<li>body: <code>this reverts commit &lt;被撤销 commit 的 SHA 标识符&gt;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &apos;graphiteWidth&apos; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>scope: 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
</li>
<li><p>subject: 是对 commit 目的的简短描述</p>
<ul>
<li>以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes</li>
<li>第一个字母小写</li>
<li>结尾不加句号</li>
</ul>
</li>
</ul>
</li>
<li><p>body: 是对 commit 的详细描述，可以分成多行</p>
<ul>
<li>使用第一人称现在时</li>
<li>应该说明代码变动的动机，以及与之前行为的对比<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">More detailed explanatory text, if necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. </span><br><span class="line"></span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line"></span><br><span class="line">- Bullet points are okay, too</span><br><span class="line">- Use a hanging indent</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>footer: 通常只用于两种情况</p>
<ul>
<li><p>不兼容变动——如果当前代码与上一个版本不兼容，则 footer 部分以 <code>BREAKING CHANGE</code> 开头，后面是对变动的描述，以及变动理由和迁移方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line"></span><br><span class="line">To migrate the code follow the example below:</span><br><span class="line"></span><br><span class="line">Before:</span><br><span class="line"></span><br><span class="line">scope: &#123;</span><br><span class="line">  myAttr: &apos;attribute&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">After:</span><br><span class="line"></span><br><span class="line">scope: &#123;</span><br><span class="line">  myAttr: &apos;@&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it.</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭 issue——如果当前 commit 针对某个 issue，那么可以在 footer 部分关闭这个issue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes #123, #245, #992</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="规范的意义"><a href="#规范的意义" class="headerlink" title="规范的意义"></a>规范的意义</h3><p>这里说说规范的好处，看看是否能够击中你工作中的痛点：</p>
<ol>
<li>提供更多的历史信息，方便快速浏览。每个 commit 占据一行，只看行首，就知道其目的。</li>
<li>可以过滤某些 commit（比如文档改动），便于快速查找信息</li>
<li>可以直接从 commit 生产 change log。change log 是发布新版本时，用来说明与上一次版本差异的文档</li>
</ol>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li>change log 中，最后只包括 type、feat、fix 类型，其他（docs、chore、style、refactor、test）建议不添加。change log 作为说明与上一个版本差异的文档，其主要受众是产品和测试。</li>
<li>revert commit 与 被撤销的 commit，在同一个发布版本（release）中，那么他们都不会出现在 chang log 中。如果两者在不同的发布版本，那么 revert commit 应该出现。</li>
</ol>
<h2 id="git-commit-工具"><a href="#git-commit-工具" class="headerlink" title="git commit 工具"></a>git commit 工具</h2><h3 id="Commitizen"><a href="#Commitizen" class="headerlink" title="Commitizen"></a>Commitizen</h3><p><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">Commitizen</a> 是一个用来撰写合格的 commit message 的工具。</p>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g commitizen</span><br></pre></td></tr></table></figure>

<h3 id="cz-conventional-changelog"><a href="#cz-conventional-changelog" class="headerlink" title="cz-conventional-changelog"></a>cz-conventional-changelog</h3><p>cz-conventional-changelog(Angular 规范) 用于为 Commitizen 提供 commit message 格式规范的 npm 包</p>
<p>其概念就是一个规范 <a href="https://github.com/commitizen/cz-cli#adapters" target="_blank" rel="noopener">Adapters</a></p>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cz-conventional-changelog</span><br></pre></td></tr></table></figure>

<p>通过 package.json 的配置引入 Commitizen：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 配置在 package.json 的根节点</span><br><span class="line">&quot;config&quot;: &#123;</span><br><span class="line">    &quot;commitizen&quot;: &#123;</span><br><span class="line">      &quot;path&quot;: &quot;cz-conventional-changelog&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 或者通过 .czrc 配置文件进行配置</span><br><span class="line">// .czrc</span><br><span class="line">&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="git-cz"><a href="#git-cz" class="headerlink" title="git-cz"></a>git-cz</h3><p>git-cz 是 commitizen 的命令行工具，有了这个 npm 包，才能使用命令调出交互界面，方便快捷的生成合格的commit message。</p>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g git-cz</span><br><span class="line">git-cz</span><br><span class="line"></span><br><span class="line">// npm 版本要求 5.2+</span><br><span class="line">npx git-cz</span><br></pre></td></tr></table></figure>

<p>运行命令可看到如下界面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git-cz</span><br><span class="line">// or</span><br><span class="line">git cz</span><br><span class="line">// or</span><br><span class="line">npx git-cz</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/33422051/59660560-7945e580-91db-11e9-8e4a-c58470549e09.png" alt="commitizen_1"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>配置 Commitizen 需要三个 npm 包：Commitizen、cz-conventional-changelog、git-cz。</p>
</li>
<li><p>commitizen 有两个配置文件</p>
<ul>
<li><p>.czrc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// .czrc</span><br><span class="line">&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>changelog.config.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// changelog.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">        &quot;test&quot;,</span><br><span class="line">        &quot;feat&quot;,</span><br><span class="line">        &quot;fix&quot;,</span><br><span class="line">        &quot;chore&quot;,</span><br><span class="line">        &quot;docs&quot;,</span><br><span class="line">        &quot;refactor&quot;,</span><br><span class="line">        &quot;style&quot;,</span><br><span class="line">        &quot;ci&quot;,</span><br><span class="line">        &quot;perf&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;maxMessageLength&quot;: 64,</span><br><span class="line">    &quot;minMessageLength&quot;: 3,</span><br><span class="line">    &quot;questions&quot;: [</span><br><span class="line">        &quot;type&quot;,</span><br><span class="line">        &quot;scope&quot;,</span><br><span class="line">        &quot;subject&quot;,</span><br><span class="line">        &quot;body&quot;,</span><br><span class="line">        &quot;breaking&quot;,</span><br><span class="line">        &quot;issues&quot;,</span><br><span class="line">        &quot;lerna&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;scopes&quot;: [],</span><br><span class="line">    &quot;types&quot;: &#123;</span><br><span class="line">        &quot;chore&quot;: &#123;</span><br><span class="line">        &quot;description&quot;: &quot;Build process or auxiliary tool changes&quot;,</span><br><span class="line">        &quot;emoji&quot;: &quot;🤖&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;chore&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ci&quot;: &#123;</span><br><span class="line">        &quot;description&quot;: &quot;CI related changes&quot;,</span><br><span class="line">        &quot;emoji&quot;: &quot;🎡&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;ci&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;docs&quot;: &#123;</span><br><span class="line">        &quot;description&quot;: &quot;Documentation only changes&quot;,</span><br><span class="line">        &quot;emoji&quot;: &quot;✏️&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;docs&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;feat&quot;: &#123;</span><br><span class="line">        &quot;description&quot;: &quot;A new feature&quot;,</span><br><span class="line">        &quot;emoji&quot;: &quot;🎸&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;feat&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;fix&quot;: &#123;</span><br><span class="line">        &quot;description&quot;: &quot;A bug fix&quot;,</span><br><span class="line">        &quot;emoji&quot;: &quot;🐛&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;fix&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;perf&quot;: &#123;</span><br><span class="line">        &quot;description&quot;: &quot;A code change that improves performance&quot;,</span><br><span class="line">        &quot;emoji&quot;: &quot;⚡️&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;perf&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;refactor&quot;: &#123;</span><br><span class="line">        &quot;description&quot;: &quot;A code change that neither fixes a bug or adds a feature&quot;,</span><br><span class="line">        &quot;emoji&quot;: &quot;💡&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;refactor&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;release&quot;: &#123;</span><br><span class="line">        &quot;description&quot;: &quot;Create a release commit&quot;,</span><br><span class="line">        &quot;emoji&quot;: &quot;🏹&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;release&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;style&quot;: &#123;</span><br><span class="line">        &quot;description&quot;: &quot;Markup, white-space, formatting, missing semi-colons...&quot;,</span><br><span class="line">        &quot;emoji&quot;: &quot;💄&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;style&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;test&quot;: &#123;</span><br><span class="line">        &quot;description&quot;: &quot;Adding missing tests&quot;,</span><br><span class="line">        &quot;emoji&quot;: &quot;💍&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;test&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>npx 相关配置，请移步<a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">官网</a></p>
</li>
<li><p>为公司多个项目统一规范，可生成自己的 Commitizen npm 包，具体操作参加<a href="https://github.com/commitizen/cz-cli#commitizen-for-multi-repo-projects" target="_blank" rel="noopener">commitizen for multi-repo projects</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="校验-commit-是否符合规范"><a href="#校验-commit-是否符合规范" class="headerlink" title="校验 commit 是否符合规范"></a>校验 commit 是否符合规范</h2><p><a href="https://conventional-changelog.github.io/commitlint/#/" target="_blank" rel="noopener">https://conventional-changelog.github.io/commitlint/#/</a></p>
<h2 id="生成-change-log"><a href="#生成-change-log" class="headerlink" title="生成 change log"></a>生成 change log</h2><p><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli" target="_blank" rel="noopener">https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli</a></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/07/14/node-sass-安装失败解决方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="swor">
      <meta itemprop="description" content="前端开发相关技术博文">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨鱼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/node-sass-安装失败解决方案/" class="post-title-link" itemprop="url">node-sass 安装失败解决方案</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-14 16:25:29 / 修改时间：16:26:22" itemprop="dateCreated datePublished" datetime="2019-07-14T16:25:29+08:00">2019-07-14</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端技术/" itemprop="url" rel="index"><span itemprop="name">前端技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install sass-loader node-sass -D</span><br><span class="line">// -S --save</span><br><span class="line">// -D --save-dev</span><br></pre></td></tr></table></figure>

<p>因网络原因，node-sass 中的二进制文件很容易下载失败。<br>可通过 <code>.npmrc</code> 进行配置指定下载链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// .npmrc</span><br><span class="line">sass_binary_site = https://npm.taobao.org/mirrors/node-sass/</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2019/07/14/brew-安装爬坑指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="swor">
      <meta itemprop="description" content="前端开发相关技术博文">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="墨鱼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/14/brew-安装爬坑指南/" class="post-title-link" itemprop="url">brew 安装爬坑指南</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-14 16:19:44 / 修改时间：16:25:05" itemprop="dateCreated datePublished" datetime="2019-07-14T16:19:44+08:00">2019-07-14</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端技术/" itemprop="url" rel="index"><span itemprop="name">前端技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">Homebrew 官网</a></p>
<p>安装命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>

<p>安装过程很慢，请自备梯子。</p>
<p>好不容易等完进度条，却报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Homebrew install: Failed during: git fetch origin master:refs/remotes/origin/master -n --depth=1</span><br></pre></td></tr></table></figure>

<p>解决方案：<a href="https://stackoverflow.com/questions/39836190/homebrew-install-failed-during-git-fetch-origin-masterrefs-remotes-origin-mas" target="_blank" rel="noopener">stackoverflow</a></p>
<p><img src="https://user-images.githubusercontent.com/33422051/59659335-93ca8f80-91d8-11e9-8b8e-34fe35193337.jpg" alt="20190412_stackoverflow"></p>
<blockquote>
<p>注意事项: 因为之前安装过一次，所以 /usr/local 目录下会创建 Cellar 和 Homebrew 。但重新安装的时候，如果检测到 Cellar 和 Homebrew 中某些文件已存在，仍然会安装失败。因此，需要移除这些目录（如果因权限问题，无法删除目录，可以删除目录里所有文件）</p>
</blockquote>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
  <p class="site-author-name" itemprop="name">swor</p>
  <div class="site-description motion-element" itemprop="description">前端开发相关技术博文</div>
</div>


  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>













          
          
        </div>
      </div>

      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">swor</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  













  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  


  

</body>
</html>
